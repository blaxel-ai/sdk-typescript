// This file is auto-generated by @hey-api/openapi-ts

/**
 * Serverless AI agent deployment that runs your custom agent code as an auto-scaling API endpoint. Agents are deployed from your code repository and expose a global inference URL for querying.
 */
export type Agent = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: AgentSpec;
    status?: Status;
};

/**
 * Serverless AI agent deployment that runs your custom agent code as an auto-scaling API endpoint. Agents are deployed from your code repository and expose a global inference URL for querying.
 */
export type AgentWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: AgentSpecWritable;
    status?: Status;
};

/**
 * Runtime configuration defining how the AI agent is deployed and scaled globally
 */
export type AgentRuntime = {
    /**
     * Environment variables injected into the agent. Supports Kubernetes EnvVar format with valueFrom references.
     */
    envs?: Array<Env>;
    /**
     * Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
     */
    generation?: 'mk2' | 'mk3';
    /**
     * Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
     */
    image?: string;
    /**
     * Maximum number of concurrent agent instances for auto-scaling under load
     */
    maxScale?: number;
    /**
     * Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
     */
    memory?: number;
    /**
     * Minimum instances to keep warm. Set to 1+ to eliminate cold starts, 0 for scale-to-zero.
     */
    minScale?: number;
};

/**
 * Configuration for an AI agent including runtime settings, repository source, and deployment triggers
 */
export type AgentSpec = {
    /**
     * When false, the agent is disabled and will not serve inference requests
     */
    enabled?: boolean;
    policies?: PoliciesList;
    repository?: Repository;
    revision?: RevisionConfiguration;
    runtime?: AgentRuntime;
    triggers?: Triggers;
};

/**
 * Configuration for an AI agent including runtime settings, repository source, and deployment triggers
 */
export type AgentSpecWritable = {
    /**
     * When false, the agent is disabled and will not serve inference requests
     */
    enabled?: boolean;
    policies?: PoliciesList;
    repository?: Repository;
    revision?: RevisionConfiguration;
    runtime?: AgentRuntime;
    triggers?: TriggersWritable;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKey = TimeFields & OwnerFields & {
    /**
     * Api key
     */
    readonly apiKey?: string;
    /**
     * Duration until expiration. Supports formats like '30d' (30 days), '24h' (24 hours), '1w' (1 week). If not set, the API key never expires.
     */
    expires_in?: string;
    /**
     * Api key id, to retrieve it from the API
     */
    readonly id?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * User subject identifier
     */
    readonly sub?: string;
    /**
     * Subject type (user or service_account)
     */
    sub_type?: string;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKeyWritable = TimeFields & OwnerFields & {
    /**
     * Duration until expiration. Supports formats like '30d' (30 days), '24h' (24 hours), '1w' (1 week). If not set, the API key never expires.
     */
    expires_in?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * Subject type (user or service_account)
     */
    sub_type?: string;
};

/**
 * Configuration
 */
export type Configuration = {
    /**
     * Continents
     */
    continents?: Array<Continent>;
    /**
     * Countries
     */
    countries?: Array<Country>;
    /**
     * Private locations managed with blaxel operator
     */
    privateLocations?: Array<PrivateLocation>;
    /**
     * Regions
     */
    regions?: Array<Region>;
};

/**
 * Continent
 */
export type Continent = {
    /**
     * Continent display name
     */
    displayName?: string;
    /**
     * Continent code
     */
    name?: string;
};

/**
 * Core event
 */
export type CoreEvent = {
    /**
     * Canary revisionID link to the event
     */
    canaryRevision?: string;
    /**
     * Event message
     */
    message?: string;
    /**
     * RevisionID link to the event
     */
    revision?: string;
    /**
     * Event status
     */
    status?: string;
    /**
     * Event time
     */
    time?: string;
    /**
     * Event type
     */
    type?: string;
};

/**
 * Core event
 */
export type CoreEventWritable = {
    /**
     * Canary revisionID link to the event
     */
    canaryRevision?: string;
    /**
     * Event message
     */
    message?: string;
    /**
     * RevisionID link to the event
     */
    revision?: string;
    /**
     * Event status
     */
    status?: string;
    /**
     * Event time
     */
    time?: string;
    /**
     * Event type
     */
    type?: string;
};

/**
 * Events happening on a resource deployed on Blaxel
 */
export type CoreEvents = Array<CoreEvent>;

/**
 * Events happening on a resource deployed on Blaxel
 */
export type CoreEventsWritable = Array<CoreEventWritable>;

/**
 * Configuration
 */
export type Country = {
    /**
     * Country display name
     */
    displayName?: string;
    /**
     * Country code
     */
    name?: string;
};

/**
 * Response returned when a job execution is successfully created. Contains identifiers and the tasks that will be executed.
 */
export type CreateJobExecutionOutput = {
    /**
     * Unique identifier for the created execution. Use this ID to track execution status, retrieve logs, or cancel the execution.
     */
    executionId?: string;
    /**
     * Unique identifier for this request, used for idempotency and tracking. Auto-generated if not provided in the request.
     */
    id?: string;
    /**
     * Name of the job that this execution belongs to
     */
    jobId?: string;
    /**
     * Array of task configurations that will be executed in parallel according to the job's concurrency settings. Each task can have custom parameters.
     */
    tasks?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Name of the workspace where the job execution was created
     */
    workspaceId?: string;
};

/**
 * Request to create a job execution
 */
export type CreateJobExecutionRequest = {
    /**
     * Environment variable overrides (optional, will merge with job's environment variables)
     */
    env?: {
        [key: string]: unknown;
    };
    /**
     * Execution ID (optional, will be generated if not provided)
     */
    executionId?: string;
    /**
     * Unique message ID
     */
    id?: string;
    /**
     * Job ID
     */
    jobId?: string;
    /**
     * Memory override in megabytes (optional, must be lower than or equal to job's configured memory)
     */
    memory?: number;
    /**
     * Array of task parameters for parallel execution
     */
    tasks?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Workspace ID
     */
    workspaceId?: string;
};

/**
 * Custom domain for preview deployments
 * The custom domain represents a base domain (e.g., example.com) that will be used
 * to serve preview deployments. Each preview will be accessible at a subdomain:
 * <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
 */
export type CustomDomain = {
    metadata: CustomDomainMetadata;
    spec: CustomDomainSpec;
};

/**
 * Custom domain for preview deployments
 * The custom domain represents a base domain (e.g., example.com) that will be used
 * to serve preview deployments. Each preview will be accessible at a subdomain:
 * <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
 */
export type CustomDomainWritable = {
    metadata: CustomDomainMetadataWritable;
    spec: CustomDomainSpecWritable;
};

/**
 * Custom domain metadata
 */
export type CustomDomainMetadata = TimeFields & OwnerFields & {
    /**
     * Display name for the custom domain
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Domain name (e.g., "example.com")
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Custom domain metadata
 */
export type CustomDomainMetadataWritable = TimeFields & OwnerFields & {
    /**
     * Display name for the custom domain
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Domain name (e.g., "example.com")
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Custom domain specification
 */
export type CustomDomainSpec = {
    /**
     * CNAME target for the domain
     */
    cnameRecords?: string;
    /**
     * Last verification attempt timestamp
     */
    readonly lastVerifiedAt?: string;
    /**
     * Region that the custom domain is associated with
     */
    region?: string;
    /**
     * Current status of the domain (pending, verified, failed)
     */
    status?: 'pending' | 'verified' | 'failed';
    /**
     * Map of TXT record names to values for domain verification
     */
    txtRecords?: {
        [key: string]: string;
    };
    /**
     * Error message if verification failed
     */
    readonly verificationError?: string;
};

/**
 * Custom domain specification
 */
export type CustomDomainSpecWritable = {
    /**
     * CNAME target for the domain
     */
    cnameRecords?: string;
    /**
     * Region that the custom domain is associated with
     */
    region?: string;
    /**
     * Current status of the domain (pending, verified, failed)
     */
    status?: 'pending' | 'verified' | 'failed';
    /**
     * Map of TXT record names to values for domain verification
     */
    txtRecords?: {
        [key: string]: string;
    };
};

/**
 * Entrypoint of the artifact
 */
export type Entrypoint = {
    /**
     * Args of the entrypoint
     */
    args?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Command of the entrypoint
     */
    command?: string;
    /**
     * Env of the entrypoint
     */
    env?: {
        [key: string]: string;
    };
    /**
     * Super Gateway args of the entrypoint
     */
    superGatewayArgs?: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * Environment variable with name and value
 */
export type Env = {
    /**
     * Name of the environment variable
     */
    name?: string;
    /**
     * Whether the value is a secret
     */
    secret?: boolean;
    /**
     * Value of the environment variable
     */
    value?: string;
};

/**
 * Standard error response returned by the API when a request fails
 */
export type _Error = {
    /**
     * HTTP status code of the error
     */
    code?: number;
    /**
     * Error type or code identifying the kind of error
     */
    error: string;
    /**
     * Human-readable error message describing what went wrong
     */
    message?: string;
};

/**
 * Expiration policy for automatic sandbox cleanup based on time conditions
 */
export type ExpirationPolicy = {
    /**
     * Action to take when the expiration condition is met
     */
    action?: 'delete';
    /**
     * Type of expiration policy: ttl-idle (delete after inactivity), ttl-max-age (delete after total lifetime), or date (delete at specific time)
     */
    type?: 'ttl-idle' | 'ttl-max-age' | 'date';
    /**
     * Duration value for TTL policies (e.g., '30m', '24h', '7d') or ISO 8601 date for date policies
     */
    value?: string;
};

/**
 * A type of hardware available for deployments
 */
export type Flavor = {
    /**
     * Flavor name (e.g. t4)
     */
    name?: string;
    /**
     * Flavor type (e.g. cpu, gpu)
     */
    type?: 'cpu' | 'gpu';
};

/**
 * Types of hardware available for deployments
 */
export type Flavors = Array<Flavor>;

/**
 * Form of the artifact
 */
export type Form = {
    /**
     * Config of the artifact
     */
    config?: {
        [key: string]: unknown;
    };
    oauth?: OAuth;
    /**
     * Secrets of the artifact
     */
    secrets?: {
        [key: string]: unknown;
    };
};

/**
 * MCP server deployment that exposes tools for AI agents via the Model Context Protocol (MCP). Deployed as a serverless auto-scaling endpoint using streamable HTTP transport.
 */
export type _Function = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: FunctionSpec;
    status?: Status;
};

/**
 * MCP server deployment that exposes tools for AI agents via the Model Context Protocol (MCP). Deployed as a serverless auto-scaling endpoint using streamable HTTP transport.
 */
export type FunctionWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: FunctionSpecWritable;
    status?: Status;
};

/**
 * Runtime configuration defining how the MCP server function is deployed and scaled
 */
export type FunctionRuntime = {
    /**
     * Environment variables injected into the function. Supports Kubernetes EnvVar format with valueFrom references.
     */
    envs?: Array<Env>;
    /**
     * Infrastructure generation: mk2 (containers, 2-10s cold starts, 15+ global regions) or mk3 (microVMs, sub-25ms cold starts)
     */
    generation?: 'mk2' | 'mk3';
    /**
     * Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
     */
    image?: string;
    /**
     * Maximum number of concurrent function instances for auto-scaling
     */
    maxScale?: number;
    /**
     * Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
     */
    memory?: number;
    /**
     * Minimum instances to keep warm. Set to 1+ to eliminate cold starts, 0 for scale-to-zero.
     */
    minScale?: number;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: 'websocket' | 'http-stream';
};

/**
 * Configuration for an MCP server function including runtime settings, transport protocol, and connected integrations
 */
export type FunctionSpec = {
    /**
     * When false, the function is disabled and will not serve requests
     */
    enabled?: boolean;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    revision?: RevisionConfiguration;
    runtime?: FunctionRuntime;
    triggers?: Triggers;
};

/**
 * Configuration for an MCP server function including runtime settings, transport protocol, and connected integrations
 */
export type FunctionSpecWritable = {
    /**
     * When false, the function is disabled and will not serve requests
     */
    enabled?: boolean;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    revision?: RevisionConfiguration;
    runtime?: FunctionRuntime;
    triggers?: TriggersWritable;
};

export type Image = {
    metadata: ImageMetadata;
    spec: ImageSpec;
};

export type ImageWritable = {
    metadata: ImageMetadataWritable;
    spec: ImageSpecWritable;
};

export type ImageMetadata = {
    /**
     * The date and time when the image was created.
     */
    readonly createdAt?: string;
    /**
     * The display name of the image (registry/workspace/repository).
     */
    displayName?: string;
    /**
     * The date and time when the image was last deployed (most recent across all tags).
     */
    readonly lastDeployedAt?: string;
    /**
     * The name of the image (repository name).
     */
    name?: string;
    /**
     * The resource type of the image.
     */
    resourceType?: string;
    /**
     * The date and time when the image was last updated.
     */
    readonly updatedAt?: string;
    /**
     * The workspace of the image.
     */
    readonly workspace?: string;
};

export type ImageMetadataWritable = {
    /**
     * The display name of the image (registry/workspace/repository).
     */
    displayName?: string;
    /**
     * The name of the image (repository name).
     */
    name?: string;
    /**
     * The resource type of the image.
     */
    resourceType?: string;
};

export type ImageSpec = {
    /**
     * The size of the image in bytes.
     */
    readonly size?: number;
    /**
     * List of tags available for this image.
     */
    tags?: Array<ImageTag>;
};

export type ImageSpecWritable = {
    /**
     * List of tags available for this image.
     */
    tags?: Array<ImageTagWritable>;
};

export type ImageTag = {
    /**
     * The date and time when the tag was created.
     */
    readonly createdAt?: string;
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * The size of the image in bytes.
     */
    readonly size?: number;
    /**
     * The date and time when the tag was last updated.
     */
    readonly updatedAt?: string;
};

export type ImageTagWritable = {
    /**
     * The name of the tag.
     */
    name?: string;
};

/**
 * Integration
 */
export type Integration = {
    /**
     * Integration additional infos
     */
    additionalInfos?: {
        [key: string]: string;
    };
    endpoints?: IntegrationEndpoints;
    headers?: IntegrationHeaders;
    /**
     * Integration name
     */
    name?: string;
    /**
     * Integration organizations
     */
    organizations?: Array<IntegrationOrganization>;
    params?: IntegrationQueryParams;
    /**
     * Integration repositories
     */
    repositories?: Array<IntegrationRepository>;
};

/**
 * Configured connection to an external service (LLM provider, API, SaaS, database) storing credentials and settings for use by workspace resources.
 */
export type IntegrationConnection = {
    metadata: Metadata;
    spec: IntegrationConnectionSpec;
};

/**
 * Configured connection to an external service (LLM provider, API, SaaS, database) storing credentials and settings for use by workspace resources.
 */
export type IntegrationConnectionWritable = {
    metadata: MetadataWritable;
    spec: IntegrationConnectionSpec;
};

/**
 * Specification defining the integration type, configuration parameters, and encrypted credentials
 */
export type IntegrationConnectionSpec = {
    /**
     * Non-sensitive configuration parameters for the integration (e.g., organization ID, region)
     */
    config?: {
        [key: string]: string;
    };
    /**
     * Integration provider type (e.g., openai, anthropic, github, slack)
     */
    integration?: string;
    /**
     * Whether this connection uses sandbox/test credentials instead of production
     */
    sandbox?: boolean;
    /**
     * Encrypted credentials and API keys for authenticating with the external service
     */
    secret?: {
        [key: string]: string;
    };
};

export type IntegrationConnectionsList = Array<string>;

/**
 * Integration endpoint
 */
export type IntegrationEndpoint = {
    /**
     * Integration endpoint body
     */
    body?: string;
    /**
     * Integration endpoint ignore models
     */
    ignoreModels?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Integration endpoint method
     */
    method?: string;
    /**
     * Integration endpoint models
     */
    models?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Integration endpoint stream key
     */
    streamKey?: string;
    streamToken?: IntegrationEndpointToken;
    token?: IntegrationEndpointToken;
};

/**
 * Integration endpoint token
 */
export type IntegrationEndpointToken = {
    /**
     * Integration endpoint token received
     */
    received?: string;
    /**
     * Integration endpoint token sent
     */
    sent?: string;
    /**
     * Integration endpoint token total
     */
    total?: string;
};

/**
 * Integration endpoints
 */
export type IntegrationEndpoints = {
    [key: string]: IntegrationEndpoint;
};

/**
 * Integration headers
 */
export type IntegrationHeaders = {
    [key: string]: string;
};

/**
 * Integration organization
 */
export type IntegrationOrganization = {
    /**
     * Provider organization avatar URL
     */
    avatar_url?: string;
    /**
     * Provider organization display name
     */
    displayName?: string;
    /**
     * Provider organization ID
     */
    id?: string;
    /**
     * Provider organization name
     */
    name?: string;
};

/**
 * Integration query params
 */
export type IntegrationQueryParams = {
    [key: string]: string;
};

/**
 * Integration repository
 */
export type IntegrationRepository = {
    /**
     * Repository ID
     */
    id?: string;
    /**
     * Whether the repository has Blaxel imports
     */
    isBl?: boolean;
    /**
     * Repository name
     */
    name?: string;
    /**
     * Repository owner
     */
    organization?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Batch processing job definition for running parallel AI tasks. Jobs can execute multiple tasks concurrently with configurable parallelism, retries, and timeouts.
 */
export type Job = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: JobSpec;
    status?: Status;
};

/**
 * Batch processing job definition for running parallel AI tasks. Jobs can execute multiple tasks concurrently with configurable parallelism, retries, and timeouts.
 */
export type JobWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: JobSpecWritable;
    status?: Status;
};

/**
 * Job execution
 */
export type JobExecution = {
    metadata: JobExecutionMetadata;
    spec: JobExecutionSpec;
    stats?: JobExecutionStats;
    status?: JobExecutionStatus;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTask>;
};

/**
 * Job execution
 */
export type JobExecutionWritable = {
    metadata: JobExecutionMetadataWritable;
    spec: JobExecutionSpecWritable;
    stats?: JobExecutionStatsWritable;
    status?: JobExecutionStatus;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTaskWritable>;
};

/**
 * Job execution metadata
 */
export type JobExecutionMetadata = {
    /**
     * Cluster ID
     */
    cluster?: string;
    /**
     * Completion timestamp
     */
    completedAt?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
    /**
     * Deletion timestamp
     */
    deletedAt?: string;
    /**
     * Expiration timestamp
     */
    expiredAt?: string;
    /**
     * Execution ID
     */
    id?: string;
    /**
     * Job name
     */
    job?: string;
    /**
     * Start timestamp
     */
    startedAt?: string;
    /**
     * Last update timestamp
     */
    updatedAt?: string;
    /**
     * Workspace ID
     */
    workspace?: string;
};

/**
 * Job execution metadata
 */
export type JobExecutionMetadataWritable = {
    /**
     * Cluster ID
     */
    cluster?: string;
    /**
     * Completion timestamp
     */
    completedAt?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
    /**
     * Deletion timestamp
     */
    deletedAt?: string;
    /**
     * Expiration timestamp
     */
    expiredAt?: string;
    /**
     * Execution ID
     */
    id?: string;
    /**
     * Job name
     */
    job?: string;
    /**
     * Start timestamp
     */
    startedAt?: string;
    /**
     * Last update timestamp
     */
    updatedAt?: string;
    /**
     * Workspace ID
     */
    workspace?: string;
};

/**
 * Job execution specification
 */
export type JobExecutionSpec = {
    /**
     * Environment variable overrides (if provided for this execution, values are masked with ***)
     */
    envOverride?: {
        [key: string]: unknown;
    };
    /**
     * Memory override in megabytes (if provided for this execution)
     */
    memoryOverride?: number;
    /**
     * Number of parallel tasks
     */
    parallelism?: number;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTask>;
    /**
     * Job timeout in seconds (captured at execution creation time)
     */
    timeout?: number;
};

/**
 * Job execution specification
 */
export type JobExecutionSpecWritable = {
    /**
     * Environment variable overrides (if provided for this execution, values are masked with ***)
     */
    envOverride?: {
        [key: string]: unknown;
    };
    /**
     * Memory override in megabytes (if provided for this execution)
     */
    memoryOverride?: number;
    /**
     * Number of parallel tasks
     */
    parallelism?: number;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTaskWritable>;
    /**
     * Job timeout in seconds (captured at execution creation time)
     */
    timeout?: number;
};

/**
 * Job execution statistics
 */
export type JobExecutionStats = {
    /**
     * Number of cancelled tasks
     */
    cancelled?: number;
    /**
     * Number of failed tasks
     */
    failure?: number;
    /**
     * Number of retried tasks
     */
    retried?: number;
    /**
     * Number of running tasks
     */
    running?: number;
    /**
     * Number of successful tasks
     */
    success?: number;
    /**
     * Total number of tasks
     */
    total?: number;
};

/**
 * Job execution statistics
 */
export type JobExecutionStatsWritable = {
    /**
     * Number of cancelled tasks
     */
    cancelled?: number;
    /**
     * Number of failed tasks
     */
    failure?: number;
    /**
     * Number of retried tasks
     */
    retried?: number;
    /**
     * Number of running tasks
     */
    running?: number;
    /**
     * Number of successful tasks
     */
    success?: number;
    /**
     * Total number of tasks
     */
    total?: number;
};

/**
 * Job execution status
 */
export type JobExecutionStatus = 'queued' | 'pending' | 'running' | 'cancelling' | 'cancelled' | 'failed' | 'succeeded' | 'timeout';

/**
 * Job execution task
 */
export type JobExecutionTask = {
    /**
     * Task conditions
     */
    conditions?: Array<JobExecutionTaskCondition>;
    metadata?: JobExecutionTaskMetadata;
    spec?: JobExecutionTaskSpec;
    status?: JobExecutionTaskStatus;
};

/**
 * Job execution task
 */
export type JobExecutionTaskWritable = {
    /**
     * Task conditions
     */
    conditions?: Array<JobExecutionTaskCondition>;
    metadata?: JobExecutionTaskMetadataWritable;
    spec?: JobExecutionTaskSpec;
    status?: JobExecutionTaskStatus;
};

/**
 * Job execution task condition
 */
export type JobExecutionTaskCondition = {
    /**
     * Execution reason
     */
    executionReason?: string;
    /**
     * Condition message
     */
    message?: string;
    /**
     * Condition reason
     */
    reason?: string;
    /**
     * Condition severity
     */
    severity?: string;
    /**
     * Condition state
     */
    state?: string;
    /**
     * Condition type
     */
    type?: string;
};

/**
 * Job execution task metadata
 */
export type JobExecutionTaskMetadata = {
    /**
     * Completion timestamp
     */
    readonly completedAt?: string;
    /**
     * Creation timestamp
     */
    readonly createdAt?: string;
    /**
     * Task name
     */
    name?: string;
    /**
     * Scheduled timestamp
     */
    readonly scheduledAt?: string;
    /**
     * Start timestamp
     */
    readonly startedAt?: string;
    /**
     * Last update timestamp
     */
    readonly updatedAt?: string;
};

/**
 * Job execution task metadata
 */
export type JobExecutionTaskMetadataWritable = {
    /**
     * Task name
     */
    name?: string;
};

/**
 * Job execution task specification
 */
export type JobExecutionTaskSpec = {
    /**
     * Maximum number of retries
     */
    maxRetries?: number;
    /**
     * Task timeout duration
     */
    timeout?: string;
};

/**
 * Job execution task status
 */
export type JobExecutionTaskStatus = 'unspecified' | 'pending' | 'reconciling' | 'failed' | 'succeeded' | 'running' | 'cancelled';

/**
 * Runtime configuration defining how batch job tasks are executed with parallelism and retry settings
 */
export type JobRuntime = {
    /**
     * Environment variables injected into job tasks. Supports Kubernetes EnvVar format with valueFrom references.
     */
    envs?: Array<Env>;
    /**
     * Infrastructure generation: mk2 (containers, 2-10s cold starts) or mk3 (microVMs, sub-25ms cold starts)
     */
    generation?: 'mk2' | 'mk3';
    /**
     * Container image built by Blaxel when deploying with 'bl deploy'. This field is auto-populated during deployment.
     */
    image?: string;
    /**
     * Maximum number of tasks that can run simultaneously within a single execution
     */
    maxConcurrentTasks?: number;
    /**
     * Number of automatic retry attempts for failed tasks before marking as failed
     */
    maxRetries?: number;
    /**
     * Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
     */
    memory?: number;
    ports?: Ports;
    /**
     * Maximum execution time in seconds before a task is terminated
     */
    timeout?: number;
};

/**
 * Configuration for a batch job including execution parameters, parallelism settings, and deployment region
 */
export type JobSpec = {
    /**
     * When false, the job is disabled and new executions cannot be triggered
     */
    enabled?: boolean;
    policies?: PoliciesList;
    /**
     * Region where the job should be created (e.g. us-was-1, eu-lon-1)
     */
    region?: string;
    revision?: RevisionConfiguration;
    runtime?: JobRuntime;
    triggers?: Triggers;
};

/**
 * Configuration for a batch job including execution parameters, parallelism settings, and deployment region
 */
export type JobSpecWritable = {
    /**
     * When false, the job is disabled and new executions cannot be triggered
     */
    enabled?: boolean;
    policies?: PoliciesList;
    /**
     * Region where the job should be created (e.g. us-was-1, eu-lon-1)
     */
    region?: string;
    revision?: RevisionConfiguration;
    runtime?: JobRuntime;
    triggers?: TriggersWritable;
};

/**
 * Location availability for policies
 */
export type LocationResponse = {
    /**
     * Continent of the location
     */
    continent?: string;
    /**
     * Country of the location
     */
    country?: string;
    /**
     * Hardware flavors available in the location
     */
    flavors?: Array<Flavor>;
    /**
     * Name of the location
     */
    location?: string;
    /**
     * Region of the location
     */
    region?: string;
    /**
     * Status of the location
     */
    status?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinition = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    entrypoint?: Entrypoint;
    form?: Form;
    /**
     * If the artifact is hidden
     */
    hidden?: boolean;
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinitionWritable = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    entrypoint?: Entrypoint;
    form?: Form;
    /**
     * If the artifact is hidden
     */
    hidden?: boolean;
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
 */
export type Metadata = TimeFields & OwnerFields & {
    /**
     * Human-readable name for display in the UI. Can contain spaces and special characters, max 63 characters.
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Unique identifier for the resource within the workspace. Must be lowercase alphanumeric with hyphens, max 49 characters. Immutable after creation.
     */
    name: string;
    /**
     * Billing plan tier applied to this resource (inherited from workspace account)
     */
    readonly plan?: string;
    /**
     * Auto-generated endpoint URL for accessing this resource (for agents, functions, models, sandboxes)
     */
    readonly url?: string;
    /**
     * Name of the workspace this resource belongs to (read-only, set automatically)
     */
    readonly workspace?: string;
};

/**
 * Common metadata fields shared by all Blaxel resources including name, labels, timestamps, and ownership information
 */
export type MetadataWritable = TimeFields & OwnerFields & {
    /**
     * Human-readable name for display in the UI. Can contain spaces and special characters, max 63 characters.
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Unique identifier for the resource within the workspace. Must be lowercase alphanumeric with hyphens, max 49 characters. Immutable after creation.
     */
    name: string;
};

/**
 * Key-value pairs for organizing and filtering resources. Labels can be used to categorize resources by environment, project, team, or any custom taxonomy.
 */
export type MetadataLabels = {
    [key: string]: string;
};

/**
 * Gateway endpoint to external LLM provider APIs (OpenAI, Anthropic, etc.) with unified access control, credentials management, and usage tracking.
 */
export type Model = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: ModelSpec;
    status?: Status;
};

/**
 * Gateway endpoint to external LLM provider APIs (OpenAI, Anthropic, etc.) with unified access control, credentials management, and usage tracking.
 */
export type ModelWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: ModelSpec;
    status?: Status;
};

/**
 * Configuration identifying which external LLM provider and model this gateway endpoint proxies to
 */
export type ModelRuntime = {
    /**
     * Provider-specific endpoint name (e.g., HuggingFace Inference Endpoints name)
     */
    endpointName?: string;
    /**
     * Model identifier at the provider (e.g., gpt-4.1, claude-sonnet-4-20250514, mistral-large-latest)
     */
    model?: string;
    /**
     * Organization or account identifier at the provider (required for some providers like OpenAI)
     */
    organization?: string;
    /**
     * LLM provider type determining the API protocol and authentication method
     */
    type?: 'hf_private_endpoint' | 'hf_public_endpoint' | 'huggingface' | 'public_model' | 'mcp' | 'openai' | 'anthropic' | 'gemini' | 'mistral' | 'deepseek' | 'cohere' | 'cerebras' | 'xai' | 'vertexai' | 'azure-openai-service' | 'azure-ai-inference' | 'azure-marketplace' | 'groq';
};

/**
 * Configuration for a model gateway endpoint including provider type, credentials, and access policies
 */
export type ModelSpec = {
    /**
     * When false, the model endpoint is disabled and will not accept inference requests
     */
    enabled?: boolean;
    flavors?: Flavors;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    runtime?: ModelRuntime;
    /**
     * When true, uses sandbox/test credentials from the integration connection
     */
    sandbox?: boolean;
};

/**
 * OAuth of the artifact
 */
export type OAuth = {
    /**
     * Scope of the OAuth
     */
    scope?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Type of the OAuth
     */
    type?: string;
};

/**
 * Owner fields for Persistance
 */
export type OwnerFields = {
    /**
     * The user or service account who created the resource
     */
    readonly createdBy?: string;
    /**
     * The user or service account who updated the resource
     */
    readonly updatedBy?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitation = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationWritable = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAccept = {
    /**
     * User email
     */
    email?: string;
    workspace?: Workspace;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAcceptWritable = {
    /**
     * User email
     */
    email?: string;
    workspace?: WorkspaceWritable;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationRender = {
    /**
     * User email
     */
    email?: string;
    /**
     * Invitation date
     */
    invitedAt?: string;
    invitedBy?: PendingInvitationRenderInvitedBy;
    /**
     * ACL role
     */
    role?: string;
    workspace?: PendingInvitationRenderWorkspace;
    workspaceDetails?: PendingInvitationWorkspaceDetails;
};

/**
 * Invited by
 */
export type PendingInvitationRenderInvitedBy = {
    /**
     * User email
     */
    email?: string;
    /**
     * User family name
     */
    family_name?: string;
    /**
     * User given name
     */
    given_name?: string;
    /**
     * User sub
     */
    sub?: string;
};

/**
 * Workspace
 */
export type PendingInvitationRenderWorkspace = {
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Workspace name
     */
    name?: string;
};

/**
 * Workspace details
 */
export type PendingInvitationWorkspaceDetails = {
    /**
     * List of user emails in the workspace
     */
    emails?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Number of users in the workspace
     */
    user_number?: number;
};

export type PoliciesList = Array<string>;

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type Policy = {
    metadata: Metadata;
    spec: PolicySpec;
};

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type PolicyWritable = {
    metadata: MetadataWritable;
    spec: PolicySpec;
};

/**
 * Policy location
 */
export type PolicyLocation = {
    /**
     * Policy location name
     */
    name?: string;
    /**
     * Policy location type
     */
    type?: 'location' | 'country' | 'continent';
};

/**
 * PolicyLocations is a local type that wraps a slice of Location
 */
export type PolicyLocations = Array<PolicyLocation>;

/**
 * PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
 */
export type PolicyMaxTokens = {
    /**
     * Granularity
     */
    granularity?: string;
    /**
     * Input
     */
    input?: number;
    /**
     * Output
     */
    output?: number;
    /**
     * RatioInputOverOutput
     */
    ratioInputOverOutput?: number;
    /**
     * Step
     */
    step?: number;
    /**
     * Total
     */
    total?: number;
};

/**
 * PolicyResourceType is a type of resource, e.g. model, function, etc.
 */
export type PolicyResourceType = 'model' | 'function' | 'agent' | 'sandbox';

/**
 * PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
 */
export type PolicyResourceTypes = Array<PolicyResourceType>;

/**
 * Policy specification
 */
export type PolicySpec = {
    flavors?: Flavors;
    locations?: PolicyLocations;
    maxTokens?: PolicyMaxTokens;
    resourceTypes?: PolicyResourceTypes;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Policy type, can be location or flavor
     */
    type?: 'location' | 'flavor' | 'maxToken';
};

/**
 * A port for a resource
 */
export type Port = {
    /**
     * The name of the port
     */
    name?: string;
    /**
     * The protocol of the port
     */
    protocol?: 'HTTP' | 'TCP' | 'UDP' | 'TLS';
    /**
     * The target port of the port
     */
    target: number;
};

/**
 * Set of ports for a resource
 */
export type Ports = Array<Port>;

/**
 * Preview of a Resource
 */
export type Preview = {
    metadata: PreviewMetadata;
    spec: PreviewSpec;
};

/**
 * Preview of a Resource
 */
export type PreviewWritable = {
    metadata: PreviewMetadataWritable;
    spec: PreviewSpecWritable;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadataWritable = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Preview of a Resource
 */
export type PreviewSpec = {
    /**
     * Custom domain bound to this preview
     */
    customDomain?: string;
    /**
     * The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * Port of the preview
     */
    port?: number;
    /**
     * Prefix URL
     */
    prefixUrl?: string;
    /**
     * Whether the preview is public
     */
    public?: boolean;
    /**
     * Region where the preview is deployed, this is readonly
     */
    readonly region?: string;
    /**
     * Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
     */
    requestHeaders?: {
        [key: string]: string;
    };
    /**
     * Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
     */
    responseHeaders?: {
        [key: string]: string;
    };
    /**
     * Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
     */
    ttl?: string;
    /**
     * URL of the preview
     */
    readonly url?: string;
};

/**
 * Preview of a Resource
 */
export type PreviewSpecWritable = {
    /**
     * Custom domain bound to this preview
     */
    customDomain?: string;
    /**
     * The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * Port of the preview
     */
    port?: number;
    /**
     * Prefix URL
     */
    prefixUrl?: string;
    /**
     * Whether the preview is public
     */
    public?: boolean;
    /**
     * Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
     */
    requestHeaders?: {
        [key: string]: string;
    };
    /**
     * Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
     */
    responseHeaders?: {
        [key: string]: string;
    };
    /**
     * Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
     */
    ttl?: string;
};

/**
 * Token for a Preview
 */
export type PreviewToken = {
    metadata: PreviewTokenMetadata;
    spec: PreviewTokenSpec;
};

/**
 * Token for a Preview
 */
export type PreviewTokenWritable = {
    metadata: PreviewTokenMetadata;
    spec: PreviewTokenSpecWritable;
};

/**
 * PreviewTokenMetadata
 */
export type PreviewTokenMetadata = {
    /**
     * Token name
     */
    name: string;
    /**
     * Preview name
     */
    previewName?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Spec for a Preview Token
 */
export type PreviewTokenSpec = {
    /**
     * Whether the token is expired
     */
    readonly expired?: boolean;
    /**
     * Expiration time of the token
     */
    expiresAt?: string;
    /**
     * Token
     */
    readonly token?: string;
};

/**
 * Spec for a Preview Token
 */
export type PreviewTokenSpecWritable = {
    /**
     * Expiration time of the token
     */
    expiresAt?: string;
};

/**
 * Private location available for policies
 */
export type PrivateLocation = {
    /**
     * Location name
     */
    name?: string;
};

export type PublicIp = {
    /**
     * Description of the region/location
     */
    description?: string;
    /**
     * List of public ipv4 addresses
     */
    ipv4Cidrs?: Array<string>;
    /**
     * List of public ipv6 addresses
     */
    ipv6Cidrs?: Array<string>;
};

export type PublicIps = {
    [key: string]: PublicIp;
};

/**
 * Region
 */
export type Region = {
    /**
     * Region display name
     */
    allowed?: string;
    /**
     * Region display name
     */
    continent?: string;
    /**
     * Region display name
     */
    country?: string;
    /**
     * Region display name
     */
    infoGeneration?: string;
    /**
     * Region display name
     */
    location?: string;
    /**
     * Region name
     */
    name?: string;
};

/**
 * Repository
 */
export type Repository = {
    /**
     * Repository type
     */
    type?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Revision configuration
 */
export type RevisionConfiguration = {
    /**
     * Active revision id
     */
    active?: string;
    /**
     * Canary revision id
     */
    canary?: string;
    /**
     * Canary revision percent
     */
    canaryPercent?: number;
    /**
     * Sticky session TTL in seconds (0 = disabled)
     */
    stickySessionTtl?: number;
    /**
     * Traffic percentage
     */
    traffic?: number;
};

/**
 * Revision metadata
 */
export type RevisionMetadata = {
    /**
     * Is the revision active
     */
    active?: boolean;
    /**
     * Is the revision canary
     */
    canary?: boolean;
    /**
     * Revision created at
     */
    readonly createdAt?: string;
    /**
     * Revision created by
     */
    readonly createdBy?: string;
    /**
     * Revision ID
     */
    readonly id?: string;
    /**
     * Is the revision previous active
     */
    previousActive?: boolean;
    /**
     * Status of the revision
     */
    readonly status?: string;
    /**
     * Percent of traffic to the revision
     */
    trafficPercent?: number;
};

/**
 * Revision metadata
 */
export type RevisionMetadataWritable = {
    /**
     * Is the revision active
     */
    active?: boolean;
    /**
     * Is the revision canary
     */
    canary?: boolean;
    /**
     * Is the revision previous active
     */
    previousActive?: boolean;
    /**
     * Percent of traffic to the revision
     */
    trafficPercent?: number;
};

/**
 * Lightweight virtual machine for secure AI code execution. Sandboxes resume from standby in under 25ms and automatically scale to zero after inactivity, preserving memory state including running processes and filesystem.
 */
export type Sandbox = {
    events?: CoreEvents;
    /**
     * Last time the sandbox was used (read-only, managed by the system)
     */
    readonly lastUsedAt?: string;
    metadata: Metadata;
    spec: SandboxSpec;
    status?: Status;
};

/**
 * Lightweight virtual machine for secure AI code execution. Sandboxes resume from standby in under 25ms and automatically scale to zero after inactivity, preserving memory state including running processes and filesystem.
 */
export type SandboxWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: SandboxSpec;
    status?: Status;
};

/**
 * Pre-configured sandbox template available in the Sandbox Hub for quick deployment with predefined tools and configurations
 */
export type SandboxDefinition = {
    /**
     * Categories of the defintion
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the definition is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the defintion
     */
    description?: string;
    /**
     * Display name of the definition
     */
    displayName?: string;
    /**
     * If the definition is enterprise
     */
    enterprise?: boolean;
    /**
     * If the definition is hidden
     */
    hidden?: boolean;
    /**
     * Icon of the definition
     */
    icon?: string;
    /**
     * Image of the Sandbox definition
     */
    image?: string;
    /**
     * Long description of the defintion
     */
    longDescription?: string;
    /**
     * Memory of the Sandbox definition in MB
     */
    memory?: number;
    /**
     * Name of the artifact
     */
    name?: string;
    ports?: Ports;
    /**
     * Tags of the definition
     */
    tags?: string;
    /**
     * URL of the definition
     */
    url?: string;
};

/**
 * Error response returned by the CreateSandbox endpoint with extended details about the failure
 */
export type SandboxError = {
    /**
     * Error code identifying the kind of error (e.g., INVALID_IMAGE, QUOTA_EXCEEDED)
     */
    code: string;
    /**
     * Additional error details. For INVALID_IMAGE errors, includes requested_image and supported_images array.
     */
    details?: {
        [key: string]: unknown;
    };
    /**
     * Human-readable error message describing what went wrong
     */
    message: string;
    /**
     * Name of the sandbox that failed to create
     */
    sandbox_name?: string;
    /**
     * HTTP status code
     */
    status_code?: number;
    /**
     * Processing step where the error occurred
     */
    step?: string;
    /**
     * ISO 8601 timestamp of when the error occurred
     */
    timestamp?: string;
    /**
     * Workspace name where the sandbox creation was attempted
     */
    workspace?: string;
};

/**
 * Lifecycle configuration controlling automatic sandbox deletion based on idle time, max age, or specific dates
 */
export type SandboxLifecycle = {
    /**
     * List of expiration policies. Multiple policies can be combined; whichever condition is met first triggers the action.
     */
    expirationPolicies?: Array<ExpirationPolicy>;
};

/**
 * Runtime configuration defining how the sandbox VM is provisioned and its resource limits
 */
export type SandboxRuntime = {
    /**
     * Environment variables injected into the sandbox. Supports Kubernetes EnvVar format with valueFrom references.
     */
    envs?: Array<Env>;
    /**
     * Absolute expiration timestamp in ISO 8601 format when the sandbox will be deleted
     */
    expires?: string;
    /**
     * Sandbox image to use. Can be a public Blaxel image (e.g., blaxel/base-image:latest) or a custom template image built with 'bl deploy'.
     */
    image?: string;
    /**
     * Memory allocation in megabytes. Also determines CPU allocation (CPU cores = memory in MB / 2048, e.g., 4096MB = 2 CPUs).
     */
    memory?: number;
    ports?: Ports;
    /**
     * Time-to-live duration after which the sandbox is automatically deleted (e.g., '30m', '24h', '7d')
     */
    ttl?: string;
};

/**
 * Configuration for a sandbox including its image, memory, ports, region, and lifecycle policies
 */
export type SandboxSpec = {
    /**
     * When false, the sandbox is disabled and will not accept connections
     */
    enabled?: boolean;
    lifecycle?: SandboxLifecycle;
    /**
     * Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1). If not specified, defaults to the region closest to the user.
     */
    region?: string;
    runtime?: SandboxRuntime;
    volumes?: VolumeAttachments;
};

/**
 * Deployment status of a resource deployed on Blaxel
 */
export type Status = 'DELETING' | 'TERMINATED' | 'FAILED' | 'DEACTIVATED' | 'DEACTIVATING' | 'UPLOADING' | 'BUILDING' | 'DEPLOYING' | 'DEPLOYED';

/**
 * Blaxel template
 */
export type Template = {
    /**
     * Default branch of the template
     */
    defaultBranch?: string;
    /**
     * Description of the template
     */
    description?: string;
    /**
     * Number of downloads/clones of the repository
     */
    downloadCount?: number;
    /**
     * Number of forks the repository has
     */
    forksCount?: number;
    /**
     * URL to the template's icon
     */
    icon?: string;
    /**
     * URL to the template's icon in dark mode
     */
    iconDark?: string;
    /**
     * Name of the template
     */
    name?: string;
    /**
     * SHA of the variable
     */
    sha?: string;
    /**
     * Number of stars the repository has
     */
    starCount?: number;
    /**
     * Topic of the template
     */
    topics?: Array<string>;
    /**
     * URL of the template
     */
    url?: string;
    /**
     * Variables of the template
     */
    variables?: Array<TemplateVariable>;
};

/**
 * Blaxel template variable
 */
export type TemplateVariable = {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Integration of the variable
     */
    integration?: string;
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Path of the variable
     */
    path?: string;
    /**
     * Whether the variable is secret
     */
    secret?: boolean;
};

/**
 * Time fields for Persistance
 */
export type TimeFields = {
    /**
     * The date and time when the resource was created
     */
    readonly createdAt?: string;
    /**
     * The date and time when the resource was updated
     */
    readonly updatedAt?: string;
};

/**
 * Trigger configuration
 */
export type Trigger = {
    configuration?: TriggerConfiguration;
    /**
     * Enable or disable the trigger (default: true)
     */
    enabled?: boolean;
    /**
     * The id of the trigger
     */
    id?: string;
    /**
     * The type of trigger, can be http or http-async
     */
    type?: 'http' | 'http-async' | 'cron';
};

/**
 * Trigger configuration
 */
export type TriggerWritable = {
    configuration?: TriggerConfigurationWritable;
    /**
     * Enable or disable the trigger (default: true)
     */
    enabled?: boolean;
    /**
     * The id of the trigger
     */
    id?: string;
    /**
     * The type of trigger, can be http or http-async
     */
    type?: 'http' | 'http-async' | 'cron';
};

/**
 * Trigger configuration
 */
export type TriggerConfiguration = {
    /**
     * The authentication type of the trigger
     */
    authenticationType?: string;
    /**
     * The callback secret for async triggers (auto-generated, encrypted)
     */
    readonly callbackSecret?: string;
    /**
     * The callback URL for async triggers (optional)
     */
    callbackUrl?: string;
    /**
     * The path of the trigger
     */
    path?: string;
    /**
     * The retry of the trigger
     */
    retry?: number;
    /**
     * The schedule of the trigger, cron expression * * * * *
     */
    schedule?: string;
    /**
     * The tasks configuration of the cronjob
     */
    tasks?: Array<TriggerConfigurationTask>;
    /**
     * The timeout in seconds for async triggers (max 900s, MK3 only)
     */
    timeout?: number;
};

/**
 * Trigger configuration
 */
export type TriggerConfigurationWritable = {
    /**
     * The authentication type of the trigger
     */
    authenticationType?: string;
    /**
     * The callback URL for async triggers (optional)
     */
    callbackUrl?: string;
    /**
     * The path of the trigger
     */
    path?: string;
    /**
     * The retry of the trigger
     */
    retry?: number;
    /**
     * The schedule of the trigger, cron expression * * * * *
     */
    schedule?: string;
    /**
     * The tasks configuration of the cronjob
     */
    tasks?: Array<TriggerConfigurationTask>;
    /**
     * The timeout in seconds for async triggers (max 900s, MK3 only)
     */
    timeout?: number;
};

/**
 * The tasks configuration of the cronjob
 */
export type TriggerConfigurationTask = {
    [key: string]: unknown;
};

/**
 * Triggers to use your agent
 */
export type Triggers = Array<Trigger>;

/**
 * Triggers to use your agent
 */
export type TriggersWritable = Array<TriggerWritable>;

/**
 * Persistent storage volume that can be attached to sandboxes for durable file storage across sessions. Volumes survive sandbox deletion and can be reattached to new sandboxes.
 */
export type Volume = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: VolumeSpec;
    state?: VolumeState;
    /**
     * Volume status computed from events
     */
    readonly status?: string;
    /**
     * Timestamp when the volume was marked for termination
     */
    readonly terminatedAt?: string;
};

/**
 * Persistent storage volume that can be attached to sandboxes for durable file storage across sessions. Volumes survive sandbox deletion and can be reattached to new sandboxes.
 */
export type VolumeWritable = {
    events?: CoreEventsWritable;
    metadata: MetadataWritable;
    spec: VolumeSpecWritable;
    state?: VolumeStateWritable;
};

/**
 * Configuration for attaching a volume to a sandbox at a specific filesystem path
 */
export type VolumeAttachment = {
    /**
     * Absolute filesystem path where the volume will be mounted inside the sandbox
     */
    mountPath?: string;
    /**
     * Name of the volume resource to attach (must exist in the same workspace and region)
     */
    name?: string;
    /**
     * If true, the volume is mounted read-only and cannot be modified by the sandbox
     */
    readOnly?: boolean;
};

export type VolumeAttachments = Array<VolumeAttachment>;

/**
 * Immutable volume configuration set at creation time (size and region cannot be changed after creation)
 */
export type VolumeSpec = {
    /**
     * The internal infrastructure resource identifier for this volume
     */
    readonly infrastructureId?: string;
    /**
     * Deployment region for the volume (e.g., us-pdx-1, eu-lon-1). Must match the region of sandboxes it attaches to.
     */
    region?: string;
    /**
     * Storage capacity in megabytes. Can be increased after creation but not decreased.
     */
    size?: number;
    /**
     * Volume template to initialize from, with optional revision (e.g., "mytemplate:1" or "mytemplate:latest")
     */
    template?: string;
};

/**
 * Immutable volume configuration set at creation time (size and region cannot be changed after creation)
 */
export type VolumeSpecWritable = {
    /**
     * Deployment region for the volume (e.g., us-pdx-1, eu-lon-1). Must match the region of sandboxes it attaches to.
     */
    region?: string;
    /**
     * Storage capacity in megabytes. Can be increased after creation but not decreased.
     */
    size?: number;
    /**
     * Volume template to initialize from, with optional revision (e.g., "mytemplate:1" or "mytemplate:latest")
     */
    template?: string;
};

/**
 * Current runtime state of the volume including attachment status
 */
export type VolumeState = {
    /**
     * Resource currently using this volume in format "type:name" (e.g., "sandbox:my-sandbox"). Empty if not attached.
     */
    attachedTo?: string;
};

/**
 * Current runtime state of the volume including attachment status
 */
export type VolumeStateWritable = {
    /**
     * Resource currently using this volume in format "type:name" (e.g., "sandbox:my-sandbox"). Empty if not attached.
     */
    attachedTo?: string;
};

/**
 * Volume template for creating pre-configured volumes
 */
export type VolumeTemplate = {
    metadata: Metadata;
    spec: VolumeTemplateSpec;
    state?: VolumeTemplateState;
    /**
     * List of versions for this template
     */
    versions?: Array<VolumeTemplateVersion>;
};

/**
 * Volume template for creating pre-configured volumes
 */
export type VolumeTemplateWritable = {
    metadata: MetadataWritable;
    spec: VolumeTemplateSpec;
    state?: VolumeTemplateStateWritable;
    /**
     * List of versions for this template
     */
    versions?: Array<VolumeTemplateVersionWritable>;
};

/**
 * Volume template specification
 */
export type VolumeTemplateSpec = {
    /**
     * Default size of the volume in MB
     */
    defaultSize?: number;
    /**
     * Description of the volume template
     */
    description?: string;
};

/**
 * Volume template state
 */
export type VolumeTemplateState = {
    /**
     * Timestamp of last version upload
     */
    readonly lastVersionUploadedAt?: string;
    /**
     * Current/latest S3 version ID
     */
    readonly latestVersion?: string;
    /**
     * Status of the volume template (created, ready, error)
     */
    status?: 'created' | 'ready' | 'error';
    /**
     * Total number of versions for this template
     */
    readonly versionCount?: number;
};

/**
 * Volume template state
 */
export type VolumeTemplateStateWritable = {
    /**
     * Status of the volume template (created, ready, error)
     */
    status?: 'created' | 'ready' | 'error';
};

/**
 * Volume template version tracking individual versions of template content
 */
export type VolumeTemplateVersion = {
    /**
     * S3 bucket name where this version is stored
     */
    readonly bucket?: string;
    /**
     * Size of the template content in bytes
     */
    readonly contentSize?: number;
    /**
     * Name of the template version
     */
    name?: string;
    /**
     * AWS region where this version is stored
     */
    readonly region?: string;
    /**
     * Status of the version (CREATED, READY, FAILED)
     */
    status?: 'CREATED' | 'READY' | 'FAILED';
    /**
     * Template name this version belongs to
     */
    templateName?: string;
    /**
     * S3 version ID for this template version
     */
    readonly versionId?: string;
    /**
     * Workspace name
     */
    readonly workspace?: string;
};

/**
 * Volume template version tracking individual versions of template content
 */
export type VolumeTemplateVersionWritable = {
    /**
     * Name of the template version
     */
    name?: string;
    /**
     * Status of the version (CREATED, READY, FAILED)
     */
    status?: 'CREATED' | 'READY' | 'FAILED';
    /**
     * Template name this version belongs to
     */
    templateName?: string;
};

/**
 * Tenant container that groups all Blaxel resources (agents, functions, models, etc.) with shared team access control and billing.
 */
export type Workspace = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Autogenerated unique workspace id
     */
    readonly id?: string;
    labels?: MetadataLabels;
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
    /**
     * Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
     */
    status?: 'created' | 'account_binded' | 'account_configured' | 'workspace_configured' | 'ready' | 'error';
    /**
     * Reason for current status (only set for error status)
     */
    readonly statusReason?: string;
};

/**
 * Tenant container that groups all Blaxel resources (agents, functions, models, etc.) with shared team access control and billing.
 */
export type WorkspaceWritable = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
    /**
     * Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
     */
    status?: 'created' | 'account_binded' | 'account_configured' | 'workspace_configured' | 'ready' | 'error';
};

/**
 * Runtime configuration for the workspace infrastructure
 */
export type WorkspaceRuntime = {
    /**
     * Infrastructure generation version for the workspace (affects available features and deployment behavior)
     */
    generation?: string;
};

/**
 * Workspace user
 */
export type WorkspaceUser = {
    /**
     * Whether the user has accepted the workspace invitation
     */
    accepted?: boolean;
    /**
     * Workspace user email
     */
    email?: string;
    /**
     * Whether the user's email has been verified
     */
    email_verified?: boolean;
    /**
     * Workspace user family name
     */
    family_name?: string;
    /**
     * Workspace user given name
     */
    given_name?: string;
    /**
     * Workspace user role
     */
    role?: string;
    /**
     * Workspace user identifier
     */
    sub?: string;
};

export type ListAgentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agents';
};

export type ListAgentsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list agents
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListAgentsError = ListAgentsErrors[keyof ListAgentsErrors];

export type ListAgentsResponses = {
    /**
     * successful operation
     */
    200: Array<Agent>;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type CreateAgentData = {
    body: AgentWritable;
    path?: never;
    query?: never;
    url: '/agents';
};

export type CreateAgentErrors = {
    /**
     * Bad request - Invalid agent configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to create agents
     */
    403: _Error;
    /**
     * Conflict - Agent with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateAgentError = CreateAgentErrors[keyof CreateAgentErrors];

export type CreateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type DeleteAgentErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this agent
     */
    403: _Error;
    /**
     * Not found - Agent does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteAgentError = DeleteAgentErrors[keyof DeleteAgentErrors];

export type DeleteAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the agent
         */
        agentName: string;
    };
    query?: {
        /**
         * Show secret values (requires workspace admin role)
         */
        show_secrets?: boolean;
    };
    url: '/agents/{agentName}';
};

export type GetAgentErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this agent
     */
    403: _Error;
    /**
     * Not found - Agent does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetAgentError = GetAgentErrors[keyof GetAgentErrors];

export type GetAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body: AgentWritable;
    path: {
        /**
         * Unique name identifier of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type UpdateAgentErrors = {
    /**
     * Bad request - Invalid agent configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this agent
     */
    403: _Error;
    /**
     * Not found - Agent does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateAgentError = UpdateAgentErrors[keyof UpdateAgentErrors];

export type UpdateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type ListAgentRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}/revisions';
};

export type ListAgentRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListAgentRevisionsResponse = ListAgentRevisionsResponses[keyof ListAgentRevisionsResponses];

export type GetConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/configuration';
};

export type GetConfigurationResponses = {
    /**
     * Configuration of the control plane
     */
    200: Configuration;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type ListCustomDomainsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type ListCustomDomainsResponses = {
    /**
     * successful operation
     */
    200: Array<CustomDomain>;
};

export type ListCustomDomainsResponse = ListCustomDomainsResponses[keyof ListCustomDomainsResponses];

export type CreateCustomDomainData = {
    body: CustomDomainWritable;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type CreateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type CreateCustomDomainResponse = CreateCustomDomainResponses[keyof CreateCustomDomainResponses];

export type DeleteCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type DeleteCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type DeleteCustomDomainResponse = DeleteCustomDomainResponses[keyof DeleteCustomDomainResponses];

export type GetCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type GetCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type GetCustomDomainResponse = GetCustomDomainResponses[keyof GetCustomDomainResponses];

export type UpdateCustomDomainData = {
    body: CustomDomainWritable;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type UpdateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type UpdateCustomDomainResponse = UpdateCustomDomainResponses[keyof UpdateCustomDomainResponses];

export type VerifyCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}/verify';
};

export type VerifyCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type VerifyCustomDomainResponse = VerifyCustomDomainResponses[keyof VerifyCustomDomainResponses];

export type ListFunctionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/functions';
};

export type ListFunctionsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list functions
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListFunctionsError = ListFunctionsErrors[keyof ListFunctionsErrors];

export type ListFunctionsResponses = {
    /**
     * successful operation
     */
    200: Array<_Function>;
};

export type ListFunctionsResponse = ListFunctionsResponses[keyof ListFunctionsResponses];

export type CreateFunctionData = {
    body: FunctionWritable;
    path?: never;
    query?: never;
    url: '/functions';
};

export type CreateFunctionErrors = {
    /**
     * Bad request - Invalid function configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to create functions
     */
    403: _Error;
    /**
     * Conflict - Function with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateFunctionError = CreateFunctionErrors[keyof CreateFunctionErrors];

export type CreateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type CreateFunctionResponse = CreateFunctionResponses[keyof CreateFunctionResponses];

export type DeleteFunctionData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the MCP server function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type DeleteFunctionErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this function
     */
    403: _Error;
    /**
     * Not found - Function does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteFunctionError = DeleteFunctionErrors[keyof DeleteFunctionErrors];

export type DeleteFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type DeleteFunctionResponse = DeleteFunctionResponses[keyof DeleteFunctionResponses];

export type GetFunctionData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the MCP server function
         */
        functionName: string;
    };
    query?: {
        /**
         * Show secret values (requires workspace admin role)
         */
        show_secrets?: boolean;
    };
    url: '/functions/{functionName}';
};

export type GetFunctionErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this function
     */
    403: _Error;
    /**
     * Not found - Function does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetFunctionError = GetFunctionErrors[keyof GetFunctionErrors];

export type GetFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type GetFunctionResponse = GetFunctionResponses[keyof GetFunctionResponses];

export type UpdateFunctionData = {
    body: FunctionWritable;
    path: {
        /**
         * Unique name identifier of the MCP server function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type UpdateFunctionErrors = {
    /**
     * Bad request - Invalid function configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this function
     */
    403: _Error;
    /**
     * Not found - Function does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateFunctionError = UpdateFunctionErrors[keyof UpdateFunctionErrors];

export type UpdateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type UpdateFunctionResponse = UpdateFunctionResponses[keyof UpdateFunctionResponses];

export type ListFunctionRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}/revisions';
};

export type ListFunctionRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListFunctionRevisionsResponse = ListFunctionRevisionsResponses[keyof ListFunctionRevisionsResponses];

export type CleanupImagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/images';
};

export type CleanupImagesResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Number of images deleted
         */
        deleted?: number;
        /**
         * Result message
         */
        message?: string;
    };
};

export type CleanupImagesResponse = CleanupImagesResponses[keyof CleanupImagesResponses];

export type ListImagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/images';
};

export type ListImagesResponses = {
    /**
     * successful operation
     */
    200: Array<Image>;
};

export type ListImagesResponse = ListImagesResponses[keyof ListImagesResponses];

export type DeleteImageData = {
    body?: never;
    path: {
        /**
         * Resource type (agents, functions, sandboxes, jobs)
         */
        resourceType: string;
        /**
         * Name of the container image repository
         */
        imageName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}';
};

export type DeleteImageErrors = {
    /**
     * image used
     */
    400: unknown;
    /**
     * image not found
     */
    404: unknown;
};

export type DeleteImageResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type DeleteImageResponse = DeleteImageResponses[keyof DeleteImageResponses];

export type GetImageData = {
    body?: never;
    path: {
        /**
         * Resource type (agents, functions, sandboxes, jobs)
         */
        resourceType: string;
        /**
         * Name of the container image repository
         */
        imageName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}';
};

export type GetImageResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type GetImageResponse = GetImageResponses[keyof GetImageResponses];

export type DeleteImageTagData = {
    body?: never;
    path: {
        /**
         * Resource type (agents, functions, sandboxes, jobs)
         */
        resourceType: string;
        /**
         * Name of the container image repository
         */
        imageName: string;
        /**
         * Tag name to delete (e.g., latest, v1.0.0)
         */
        tagName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}/tags/{tagName}';
};

export type DeleteImageTagErrors = {
    /**
     * tag is in use
     */
    400: unknown;
    /**
     * image or tag not found
     */
    404: unknown;
};

export type DeleteImageTagResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type DeleteImageTagResponse = DeleteImageTagResponses[keyof DeleteImageTagResponses];

export type GetIntegrationData = {
    body?: never;
    path: {
        /**
         * Name of the integration
         */
        integrationName: string;
    };
    query?: never;
    url: '/integrations/{integrationName}';
};

export type GetIntegrationResponses = {
    /**
     * successful operation
     */
    200: Integration;
};

export type GetIntegrationResponse = GetIntegrationResponses[keyof GetIntegrationResponses];

export type ListIntegrationConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type ListIntegrationConnectionsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list integration connections
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListIntegrationConnectionsError = ListIntegrationConnectionsErrors[keyof ListIntegrationConnectionsErrors];

export type ListIntegrationConnectionsResponses = {
    /**
     * successful operation
     */
    200: Array<IntegrationConnection>;
};

export type ListIntegrationConnectionsResponse = ListIntegrationConnectionsResponses[keyof ListIntegrationConnectionsResponses];

export type CreateIntegrationConnectionData = {
    body: IntegrationConnectionWritable;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type CreateIntegrationConnectionErrors = {
    /**
     * Bad request - Invalid integration configuration or unsupported integration type
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to create integration connections
     */
    403: _Error;
    /**
     * Conflict - Integration connection with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateIntegrationConnectionError = CreateIntegrationConnectionErrors[keyof CreateIntegrationConnectionErrors];

export type CreateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type CreateIntegrationConnectionResponse = CreateIntegrationConnectionResponses[keyof CreateIntegrationConnectionResponses];

export type DeleteIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the integration connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type DeleteIntegrationConnectionErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this connection
     */
    403: _Error;
    /**
     * Not found - Integration connection does not exist
     */
    404: _Error;
    /**
     * Conflict - Integration connection is in use by models or functions
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteIntegrationConnectionError = DeleteIntegrationConnectionErrors[keyof DeleteIntegrationConnectionErrors];

export type DeleteIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type DeleteIntegrationConnectionResponse = DeleteIntegrationConnectionResponses[keyof DeleteIntegrationConnectionResponses];

export type GetIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the integration connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type GetIntegrationConnectionErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this connection
     */
    403: _Error;
    /**
     * Not found - Integration connection does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetIntegrationConnectionError = GetIntegrationConnectionErrors[keyof GetIntegrationConnectionErrors];

export type GetIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type GetIntegrationConnectionResponse = GetIntegrationConnectionResponses[keyof GetIntegrationConnectionResponses];

export type UpdateIntegrationConnectionData = {
    body: IntegrationConnectionWritable;
    path: {
        /**
         * Unique name identifier of the integration connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type UpdateIntegrationConnectionErrors = {
    /**
     * Bad request - Invalid integration configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this connection
     */
    403: _Error;
    /**
     * Not found - Integration connection does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateIntegrationConnectionError = UpdateIntegrationConnectionErrors[keyof UpdateIntegrationConnectionErrors];

export type UpdateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type UpdateIntegrationConnectionResponse = UpdateIntegrationConnectionResponses[keyof UpdateIntegrationConnectionResponses];

export type GetIntegrationConnectionModelEndpointConfigurationsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/endpointConfigurations';
};

export type GetIntegrationConnectionModelEndpointConfigurationsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListIntegrationConnectionModelsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models';
};

export type ListIntegrationConnectionModelsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetIntegrationConnectionModelData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
        /**
         * Model ID
         */
        modelId: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models/{modelId}';
};

export type GetIntegrationConnectionModelResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListJobsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type ListJobsResponses = {
    /**
     * successful operation
     */
    200: Array<Job>;
};

export type ListJobsResponse = ListJobsResponses[keyof ListJobsResponses];

export type CreateJobData = {
    body: JobWritable;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type CreateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type CreateJobResponse = CreateJobResponses[keyof CreateJobResponses];

export type DeleteJobData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the batch job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type DeleteJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type DeleteJobResponse = DeleteJobResponses[keyof DeleteJobResponses];

export type GetJobData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the batch job
         */
        jobId: string;
    };
    query?: {
        /**
         * Show secret values (requires workspace admin role)
         */
        show_secrets?: boolean;
    };
    url: '/jobs/{jobId}';
};

export type GetJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type GetJobResponse = GetJobResponses[keyof GetJobResponses];

export type UpdateJobData = {
    body: JobWritable;
    path: {
        /**
         * Unique name identifier of the batch job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type UpdateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];

export type ListJobExecutionsData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: {
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Page offset
         */
        offset?: number;
    };
    url: '/jobs/{jobId}/executions';
};

export type ListJobExecutionsErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type ListJobExecutionsResponses = {
    /**
     * successful operation
     */
    200: Array<JobExecution>;
};

export type ListJobExecutionsResponse = ListJobExecutionsResponses[keyof ListJobExecutionsResponses];

export type CreateJobExecutionData = {
    body: CreateJobExecutionRequest;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions';
};

export type CreateJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type CreateJobExecutionResponses = {
    /**
     * successful operation
     */
    200: CreateJobExecutionOutput;
};

export type CreateJobExecutionResponse = CreateJobExecutionResponses[keyof CreateJobExecutionResponses];

export type DeleteJobExecutionData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
        /**
         * Id of the execution
         */
        executionId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions/{executionId}';
};

export type DeleteJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * execution not found
     */
    404: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type DeleteJobExecutionResponses = {
    /**
     * successful operation
     */
    200: JobExecution;
};

export type DeleteJobExecutionResponse = DeleteJobExecutionResponses[keyof DeleteJobExecutionResponses];

export type GetJobExecutionData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
        /**
         * Id of the execution
         */
        executionId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions/{executionId}';
};

export type GetJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * execution not found
     */
    404: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type GetJobExecutionResponses = {
    /**
     * successful operation
     */
    200: JobExecution;
};

export type GetJobExecutionResponse = GetJobExecutionResponses[keyof GetJobExecutionResponses];

export type ListJobRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/revisions';
};

export type ListJobRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListJobRevisionsResponse = ListJobRevisionsResponses[keyof ListJobRevisionsResponses];

export type ListLocationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/locations';
};

export type ListLocationsResponses = {
    /**
     * successful operation
     */
    200: Array<LocationResponse>;
};

export type ListLocationsResponse = ListLocationsResponses[keyof ListLocationsResponses];

export type ListMcpHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mcp/hub';
};

export type ListMcpHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<McpDefinition>;
};

export type ListMcpHubDefinitionsResponse = ListMcpHubDefinitionsResponses[keyof ListMcpHubDefinitionsResponses];

export type ListModelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/models';
};

export type ListModelsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list models
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListModelsError = ListModelsErrors[keyof ListModelsErrors];

export type ListModelsResponses = {
    /**
     * successful operation
     */
    200: Array<Model>;
};

export type ListModelsResponse = ListModelsResponses[keyof ListModelsResponses];

export type CreateModelData = {
    body: ModelWritable;
    path?: never;
    query?: never;
    url: '/models';
};

export type CreateModelErrors = {
    /**
     * Bad request - Invalid model configuration or integration connection not found
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to create models
     */
    403: _Error;
    /**
     * Conflict - Model with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateModelError = CreateModelErrors[keyof CreateModelErrors];

export type CreateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type CreateModelResponse = CreateModelResponses[keyof CreateModelResponses];

export type DeleteModelData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the model endpoint
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type DeleteModelErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this model
     */
    403: _Error;
    /**
     * Not found - Model does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteModelError = DeleteModelErrors[keyof DeleteModelErrors];

export type DeleteModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type DeleteModelResponse = DeleteModelResponses[keyof DeleteModelResponses];

export type GetModelData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the model endpoint
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type GetModelErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this model
     */
    403: _Error;
    /**
     * Not found - Model does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetModelError = GetModelErrors[keyof GetModelErrors];

export type GetModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type GetModelResponse = GetModelResponses[keyof GetModelResponses];

export type UpdateModelData = {
    body: ModelWritable;
    path: {
        /**
         * Unique name identifier of the model endpoint
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type UpdateModelErrors = {
    /**
     * Bad request - Invalid model configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this model
     */
    403: _Error;
    /**
     * Not found - Model does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateModelError = UpdateModelErrors[keyof UpdateModelErrors];

export type UpdateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type UpdateModelResponse = UpdateModelResponses[keyof UpdateModelResponses];

export type ListModelRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}/revisions';
};

export type ListModelRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListModelRevisionsResponse = ListModelRevisionsResponses[keyof ListModelRevisionsResponses];

export type ListPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/policies';
};

export type ListPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<Policy>;
};

export type ListPoliciesResponse = ListPoliciesResponses[keyof ListPoliciesResponses];

export type CreatePolicyData = {
    body: PolicyWritable;
    path?: never;
    query?: never;
    url: '/policies';
};

export type CreatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type CreatePolicyResponse = CreatePolicyResponses[keyof CreatePolicyResponses];

export type DeletePolicyData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type DeletePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type DeletePolicyResponse = DeletePolicyResponses[keyof DeletePolicyResponses];

export type GetPolicyData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type GetPolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type GetPolicyResponse = GetPolicyResponses[keyof GetPolicyResponses];

export type UpdatePolicyData = {
    body: PolicyWritable;
    path: {
        /**
         * Unique name identifier of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type UpdatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type UpdatePolicyResponse = UpdatePolicyResponses[keyof UpdatePolicyResponses];

export type ListPublicIpsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by region name (only returns mk3 region data)
         */
        region?: string;
    };
    url: '/publicIps';
};

export type ListPublicIpsResponses = {
    /**
     * successful operation
     */
    200: PublicIps;
};

export type ListPublicIpsResponse = ListPublicIpsResponses[keyof ListPublicIpsResponses];

export type ListSandboxHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandbox/hub';
};

export type ListSandboxHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<SandboxDefinition>;
};

export type ListSandboxHubDefinitionsResponse = ListSandboxHubDefinitionsResponses[keyof ListSandboxHubDefinitionsResponses];

export type ListSandboxesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type ListSandboxesErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list sandboxes
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListSandboxesError = ListSandboxesErrors[keyof ListSandboxesErrors];

export type ListSandboxesResponses = {
    /**
     * successful operation
     */
    200: Array<Sandbox>;
};

export type ListSandboxesResponse = ListSandboxesResponses[keyof ListSandboxesResponses];

export type CreateSandboxData = {
    body: SandboxWritable;
    path?: never;
    query?: {
        /**
         * If true, return existing sandbox instead of 409 error when sandbox exists and is not in FAILED/TERMINATED/TERMINATING state
         */
        createIfNotExist?: boolean;
    };
    url: '/sandboxes';
};

export type CreateSandboxErrors = {
    /**
     * Bad request - Invalid sandbox configuration (e.g., invalid region, image not found)
     */
    400: SandboxError;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: SandboxError;
    /**
     * Forbidden - Insufficient permissions to create sandboxes
     */
    403: SandboxError;
    /**
     * Conflict - Sandbox with this name already exists
     */
    409: SandboxError;
    /**
     * Internal server error
     */
    500: SandboxError;
};

export type CreateSandboxError = CreateSandboxErrors[keyof CreateSandboxErrors];

export type CreateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type CreateSandboxResponse = CreateSandboxResponses[keyof CreateSandboxResponses];

export type DeleteSandboxData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type DeleteSandboxErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this sandbox
     */
    403: _Error;
    /**
     * Not found - Sandbox does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteSandboxError = DeleteSandboxErrors[keyof DeleteSandboxErrors];

export type DeleteSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type DeleteSandboxResponse = DeleteSandboxResponses[keyof DeleteSandboxResponses];

export type GetSandboxData = {
    body?: never;
    path: {
        /**
         * Unique name identifier of the sandbox
         */
        sandboxName: string;
    };
    query?: {
        /**
         * Show secret values (requires workspace admin role)
         */
        show_secrets?: boolean;
    };
    url: '/sandboxes/{sandboxName}';
};

export type GetSandboxErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this sandbox
     */
    403: _Error;
    /**
     * Not found - Sandbox does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetSandboxError = GetSandboxErrors[keyof GetSandboxErrors];

export type GetSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type GetSandboxResponse = GetSandboxResponses[keyof GetSandboxResponses];

export type UpdateSandboxData = {
    body: SandboxWritable;
    path: {
        /**
         * Unique name identifier of the sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type UpdateSandboxErrors = {
    /**
     * Bad request - Invalid sandbox configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this sandbox
     */
    403: _Error;
    /**
     * Not found - Sandbox does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateSandboxError = UpdateSandboxErrors[keyof UpdateSandboxErrors];

export type UpdateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type UpdateSandboxResponse = UpdateSandboxResponses[keyof UpdateSandboxResponses];

export type ListSandboxPreviewsData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type ListSandboxPreviewsResponses = {
    /**
     * successful operation
     */
    200: Array<Preview>;
};

export type ListSandboxPreviewsResponse = ListSandboxPreviewsResponses[keyof ListSandboxPreviewsResponses];

export type CreateSandboxPreviewData = {
    body: PreviewWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type CreateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type CreateSandboxPreviewResponse = CreateSandboxPreviewResponses[keyof CreateSandboxPreviewResponses];

export type DeleteSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type DeleteSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type DeleteSandboxPreviewResponse = DeleteSandboxPreviewResponses[keyof DeleteSandboxPreviewResponses];

export type GetSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type GetSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type GetSandboxPreviewResponse = GetSandboxPreviewResponses[keyof GetSandboxPreviewResponses];

export type UpdateSandboxPreviewData = {
    body: PreviewWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type UpdateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type UpdateSandboxPreviewResponse = UpdateSandboxPreviewResponses[keyof UpdateSandboxPreviewResponses];

export type ListSandboxPreviewTokensData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type ListSandboxPreviewTokensResponses = {
    /**
     * successful operation
     */
    200: Array<PreviewToken>;
};

export type ListSandboxPreviewTokensResponse = ListSandboxPreviewTokensResponses[keyof ListSandboxPreviewTokensResponses];

export type CreateSandboxPreviewTokenData = {
    body: PreviewTokenWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type CreateSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: PreviewToken;
};

export type CreateSandboxPreviewTokenResponse = CreateSandboxPreviewTokenResponses[keyof CreateSandboxPreviewTokenResponses];

export type DeleteSandboxPreviewTokenData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
        /**
         * Name of the Token
         */
        tokenName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens/{tokenName}';
};

export type DeleteSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type DeleteSandboxPreviewTokenResponse = DeleteSandboxPreviewTokenResponses[keyof DeleteSandboxPreviewTokenResponses];

export type GetWorkspaceServiceAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type GetWorkspaceServiceAccountsResponses = {
    /**
     * successful operation
     */
    200: Array<{
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    }>;
};

export type GetWorkspaceServiceAccountsResponse = GetWorkspaceServiceAccountsResponses[keyof GetWorkspaceServiceAccountsResponses];

export type CreateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type CreateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Service account client secret (only returned on creation)
         */
        client_secret?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type CreateWorkspaceServiceAccountResponse = CreateWorkspaceServiceAccountResponses[keyof CreateWorkspaceServiceAccountResponses];

export type DeleteWorkspaceServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type DeleteWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type DeleteWorkspaceServiceAccountResponse = DeleteWorkspaceServiceAccountResponses[keyof DeleteWorkspaceServiceAccountResponses];

export type UpdateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type UpdateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type UpdateWorkspaceServiceAccountResponse = UpdateWorkspaceServiceAccountResponses[keyof UpdateWorkspaceServiceAccountResponses];

export type ListApiKeysForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Service account client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type ListApiKeysForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: Array<ApiKey>;
};

export type ListApiKeysForServiceAccountResponse = ListApiKeysForServiceAccountResponses[keyof ListApiKeysForServiceAccountResponses];

export type CreateApiKeyForServiceAccountData = {
    body: {
        /**
         * Expiration period for the API key. Supports formats like '30d' (30 days), '24h' (24 hours), '1w' (1 week). If not set, the API key never expires.
         */
        expires_in?: string;
        /**
         * Name for the API key
         */
        name?: string;
    };
    path: {
        /**
         * Service account client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type CreateApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: ApiKey;
};

export type CreateApiKeyForServiceAccountResponse = CreateApiKeyForServiceAccountResponses[keyof CreateApiKeyForServiceAccountResponses];

export type DeleteApiKeyForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Service account client ID
         */
        clientId: string;
        /**
         * API key identifier to revoke
         */
        apiKeyId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys/{apiKeyId}';
};

export type DeleteApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/templates';
};

export type ListTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<Template>;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the template
         */
        templateName: string;
    };
    query?: never;
    url: '/templates/{templateName}';
};

export type GetTemplateResponses = {
    /**
     * successful operation
     */
    200: Template;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type ListWorkspaceUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/users';
};

export type ListWorkspaceUsersResponses = {
    /**
     * successful operation
     */
    200: Array<WorkspaceUser>;
};

export type ListWorkspaceUsersResponse = ListWorkspaceUsersResponses[keyof ListWorkspaceUsersResponses];

export type InviteWorkspaceUserData = {
    /**
     * Email of the user to invite
     */
    body: {
        email?: string;
    };
    path?: never;
    query?: never;
    url: '/users';
};

export type InviteWorkspaceUserErrors = {
    /**
     * invalid email format
     */
    400: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type InviteWorkspaceUserResponses = {
    /**
     * successful operation
     */
    200: PendingInvitation;
};

export type InviteWorkspaceUserResponse = InviteWorkspaceUserResponses[keyof InviteWorkspaceUserResponses];

export type RemoveWorkspaceUserData = {
    body?: never;
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type RemoveWorkspaceUserErrors = {
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type RemoveWorkspaceUserResponses = {
    /**
     * User successfully removed or invitation revoked
     */
    200: unknown;
};

export type UpdateWorkspaceUserRoleData = {
    body: {
        /**
         * The new role to assign to the user
         */
        role: string;
    };
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type UpdateWorkspaceUserRoleErrors = {
    /**
     * Invalid role provided
     */
    400: unknown;
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type UpdateWorkspaceUserRoleResponses = {
    /**
     * User role updated successfully
     */
    200: WorkspaceUser;
};

export type UpdateWorkspaceUserRoleResponse = UpdateWorkspaceUserRoleResponses[keyof UpdateWorkspaceUserRoleResponses];

export type ListVolumeTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/volume_templates';
};

export type ListVolumeTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<VolumeTemplate>;
};

export type ListVolumeTemplatesResponse = ListVolumeTemplatesResponses[keyof ListVolumeTemplatesResponses];

export type CreateVolumeTemplateData = {
    body: VolumeTemplateWritable;
    path?: never;
    query?: {
        /**
         * If true, returns a presigned URL for uploading the template content
         */
        upload?: boolean;
        /**
         * Version name for the template version being created
         */
        version?: string;
    };
    url: '/volume_templates';
};

export type CreateVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type CreateVolumeTemplateResponse = CreateVolumeTemplateResponses[keyof CreateVolumeTemplateResponses];

export type DeleteVolumeTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}';
};

export type DeleteVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type DeleteVolumeTemplateResponse = DeleteVolumeTemplateResponses[keyof DeleteVolumeTemplateResponses];

export type GetVolumeTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}';
};

export type GetVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type GetVolumeTemplateResponse = GetVolumeTemplateResponses[keyof GetVolumeTemplateResponses];

export type UpdateVolumeTemplateData = {
    body: VolumeTemplateWritable;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: {
        /**
         * If true, returns a presigned URL for uploading the template content
         */
        upload?: boolean;
        /**
         * Version name for the template version being created
         */
        version?: string;
    };
    url: '/volume_templates/{volumeTemplateName}';
};

export type UpdateVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type UpdateVolumeTemplateResponse = UpdateVolumeTemplateResponses[keyof UpdateVolumeTemplateResponses];

export type DeleteVolumeTemplateVersionData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
        /**
         * Name of the version to delete
         */
        versionName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}/versions/{versionName}';
};

export type DeleteVolumeTemplateVersionErrors = {
    /**
     * Cannot delete the only version
     */
    400: unknown;
    /**
     * Version not found
     */
    404: unknown;
};

export type DeleteVolumeTemplateVersionResponses = {
    /**
     * Version deleted successfully
     */
    200: {
        message?: string;
        template?: VolumeTemplate;
    };
};

export type DeleteVolumeTemplateVersionResponse = DeleteVolumeTemplateVersionResponses[keyof DeleteVolumeTemplateVersionResponses];

export type ListVolumesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type ListVolumesErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to list volumes
     */
    403: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListVolumesError = ListVolumesErrors[keyof ListVolumesErrors];

export type ListVolumesResponses = {
    /**
     * successful operation
     */
    200: Array<Volume>;
};

export type ListVolumesResponse = ListVolumesResponses[keyof ListVolumesResponses];

export type CreateVolumeData = {
    body: VolumeWritable;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type CreateVolumeErrors = {
    /**
     * Bad request - Invalid volume configuration (e.g., invalid region)
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to create volumes
     */
    403: _Error;
    /**
     * Conflict - Volume with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateVolumeError = CreateVolumeErrors[keyof CreateVolumeErrors];

export type CreateVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type CreateVolumeResponse = CreateVolumeResponses[keyof CreateVolumeResponses];

export type DeleteVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type DeleteVolumeErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to delete this volume
     */
    403: _Error;
    /**
     * Not found - Volume does not exist
     */
    404: _Error;
    /**
     * Conflict - Volume is currently attached to a sandbox
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteVolumeError = DeleteVolumeErrors[keyof DeleteVolumeErrors];

export type DeleteVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type DeleteVolumeResponse = DeleteVolumeResponses[keyof DeleteVolumeResponses];

export type GetVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type GetVolumeErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to view this volume
     */
    403: _Error;
    /**
     * Not found - Volume does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetVolumeError = GetVolumeErrors[keyof GetVolumeErrors];

export type GetVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type GetVolumeResponse = GetVolumeResponses[keyof GetVolumeResponses];

export type UpdateVolumeData = {
    body: VolumeWritable;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type UpdateVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type UpdateVolumeResponse = UpdateVolumeResponses[keyof UpdateVolumeResponses];

export type ListWorkspacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type ListWorkspacesErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type ListWorkspacesError = ListWorkspacesErrors[keyof ListWorkspacesErrors];

export type ListWorkspacesResponses = {
    /**
     * successful operation
     */
    200: Array<Workspace>;
};

export type ListWorkspacesResponse = ListWorkspacesResponses[keyof ListWorkspacesResponses];

export type CreateWorkspaceData = {
    body: WorkspaceWritable;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type CreateWorkspaceErrors = {
    /**
     * Bad request - Invalid workspace configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions or no billing account linked
     */
    403: _Error;
    /**
     * Conflict - Workspace with this name already exists
     */
    409: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type CreateWorkspaceError = CreateWorkspaceErrors[keyof CreateWorkspaceErrors];

export type CreateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type CreateWorkspaceResponse = CreateWorkspaceResponses[keyof CreateWorkspaceResponses];

export type DeleteWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type DeleteWorkspaceErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Only workspace admins can delete workspaces
     */
    403: _Error;
    /**
     * Not found - Workspace does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type DeleteWorkspaceError = DeleteWorkspaceErrors[keyof DeleteWorkspaceErrors];

export type DeleteWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type DeleteWorkspaceResponse = DeleteWorkspaceResponses[keyof DeleteWorkspaceResponses];

export type GetWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type GetWorkspaceErrors = {
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - You do not have access to this workspace
     */
    403: _Error;
    /**
     * Not found - Workspace does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type GetWorkspaceError = GetWorkspaceErrors[keyof GetWorkspaceErrors];

export type GetWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type GetWorkspaceResponse = GetWorkspaceResponses[keyof GetWorkspaceResponses];

export type UpdateWorkspaceData = {
    body: WorkspaceWritable;
    path: {
        /**
         * name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type UpdateWorkspaceErrors = {
    /**
     * Bad request - Invalid workspace configuration
     */
    400: _Error;
    /**
     * Unauthorized - Invalid or missing authentication credentials
     */
    401: _Error;
    /**
     * Forbidden - Insufficient permissions to update this workspace
     */
    403: _Error;
    /**
     * Not found - Workspace does not exist
     */
    404: _Error;
    /**
     * Internal server error
     */
    500: _Error;
};

export type UpdateWorkspaceError = UpdateWorkspaceErrors[keyof UpdateWorkspaceErrors];

export type UpdateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type UpdateWorkspaceResponse = UpdateWorkspaceResponses[keyof UpdateWorkspaceResponses];

export type DeclineWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/decline';
};

export type DeclineWorkspaceInvitationResponses = {
    /**
     * Invitation successfully declined
     */
    200: PendingInvitation;
};

export type DeclineWorkspaceInvitationResponse = DeclineWorkspaceInvitationResponses[keyof DeclineWorkspaceInvitationResponses];

export type AcceptWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/join';
};

export type AcceptWorkspaceInvitationErrors = {
    /**
     * Workspace or invitation not found
     */
    404: unknown;
};

export type AcceptWorkspaceInvitationResponses = {
    /**
     * Invitation successfully accepted
     */
    200: PendingInvitationAccept;
};

export type AcceptWorkspaceInvitationResponse = AcceptWorkspaceInvitationResponses[keyof AcceptWorkspaceInvitationResponses];

export type LeaveWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/leave';
};

export type LeaveWorkspaceErrors = {
    /**
     * Workspace not found
     */
    404: unknown;
};

export type LeaveWorkspaceResponses = {
    /**
     * Workspace successfully left
     */
    200: Workspace;
};

export type LeaveWorkspaceResponse = LeaveWorkspaceResponses[keyof LeaveWorkspaceResponses];

export type CheckWorkspaceAvailabilityData = {
    body: {
        name: string;
    };
    path?: never;
    query?: never;
    url: '/workspaces/availability';
};

export type CheckWorkspaceAvailabilityResponses = {
    /**
     * successful operation
     */
    200: boolean;
};

export type CheckWorkspaceAvailabilityResponse = CheckWorkspaceAvailabilityResponses[keyof CheckWorkspaceAvailabilityResponses];

export type ClientOptions = {
    baseUrl: 'https://api.blaxel.ai/v0' | 'https://run.blaxel.ai' | (string & {});
};