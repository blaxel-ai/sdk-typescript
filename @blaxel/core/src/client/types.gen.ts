// This file is auto-generated by @hey-api/openapi-ts

/**
 * ACL
 */
export type Acl = TimeFields & {
    /**
     * ACL id
     */
    id?: string;
    /**
     * Resource ID
     */
    resource_id?: string;
    /**
     * Resource type
     */
    resource_type?: string;
    /**
     * Role
     */
    role?: string;
    /**
     * Subject ID
     */
    subject_id?: string;
    /**
     * Subject type
     */
    subject_type?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * ACL
 */
export type AclWritable = TimeFields & {
    /**
     * ACL id
     */
    id?: string;
    /**
     * Resource ID
     */
    resource_id?: string;
    /**
     * Resource type
     */
    resource_type?: string;
    /**
     * Role
     */
    role?: string;
    /**
     * Subject ID
     */
    subject_id?: string;
    /**
     * Subject type
     */
    subject_type?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Agent
 */
export type Agent = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: AgentSpec;
    status?: Status;
};

/**
 * Agent
 */
export type AgentWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: AgentSpec;
    status?: Status;
};

/**
 * Runtime configuration for Agent
 */
export type AgentRuntime = {
    /**
     * The env variables to set in the agent. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The generation of the agent
     */
    generation?: 'mk2' | 'mk3';
    /**
     * The Docker image for the agent
     */
    image?: string;
    /**
     * The maximum number of replicas for the agent.
     */
    maxScale?: number;
    /**
     * The memory for the agent in MB
     */
    memory?: number;
    /**
     * The minimum number of replicas for the agent. Can be 0 or 1 (in which case the agent is always running in at least one location).
     */
    minScale?: number;
};

/**
 * Agent specification for API
 */
export type AgentSpec = {
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    policies?: PoliciesList;
    repository?: Repository;
    revision?: RevisionConfiguration;
    runtime?: AgentRuntime;
    triggers?: Triggers;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKey = TimeFields & OwnerFields & {
    /**
     * Api key
     */
    apiKey?: string;
    /**
     * Duration until expiration (in seconds)
     */
    expires_in?: string;
    /**
     * Api key id, to retrieve it from the API
     */
    id?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * User subject identifier
     */
    sub?: string;
    /**
     * Subject type
     */
    sub_type?: string;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKeyWritable = TimeFields & OwnerFields & {
    /**
     * Api key
     */
    apiKey?: string;
    /**
     * Duration until expiration (in seconds)
     */
    expires_in?: string;
    /**
     * Api key id, to retrieve it from the API
     */
    id?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * User subject identifier
     */
    sub?: string;
    /**
     * Subject type
     */
    sub_type?: string;
};

/**
 * Array of metrics
 */
export type ArrayMetric = Array<Metric>;

/**
 * Billable time metric
 */
export type BillableTimeMetric = {
    /**
     * Billable time
     */
    billableTime?: Array<JobsChartValue>;
    /**
     * Total memory allocation in GB-seconds
     */
    totalAllocation?: number;
};

/**
 * Configuration
 */
export type Configuration = {
    /**
     * Continents
     */
    continents?: Array<Continent>;
    /**
     * Countries
     */
    countries?: Array<Country>;
    /**
     * Private locations managed with blaxel operator
     */
    privateLocations?: Array<PrivateLocation>;
    /**
     * Regions
     */
    regions?: Array<Region>;
};

/**
 * Continent
 */
export type Continent = {
    /**
     * Continent display name
     */
    displayName?: string;
    /**
     * Continent code
     */
    name?: string;
};

/**
 * Core event
 */
export type CoreEvent = {
    /**
     * Canary revisionID link to the event
     */
    canaryRevision?: string;
    /**
     * Event message
     */
    message?: string;
    /**
     * RevisionID link to the event
     */
    revision?: string;
    /**
     * Event status
     */
    status?: string;
    /**
     * Event time
     */
    time?: string;
    /**
     * Event type
     */
    type?: string;
};

/**
 * Core events
 */
export type CoreEvents = Array<CoreEvent>;

/**
 * Configuration
 */
export type Country = {
    /**
     * Country display name
     */
    displayName?: string;
    /**
     * Country code
     */
    name?: string;
};

/**
 * Request to create a job execution
 */
export type CreateJobExecutionRequest = {
    /**
     * Execution ID (optional, will be generated if not provided)
     */
    executionId?: string;
    /**
     * Unique message ID
     */
    id?: string;
    /**
     * Job ID
     */
    jobId?: string;
    /**
     * Array of task parameters for parallel execution
     */
    tasks?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Workspace ID
     */
    workspaceId?: string;
};

/**
 * Custom domain for preview deployments
 * The custom domain represents a base domain (e.g., example.com) that will be used
 * to serve preview deployments. Each preview will be accessible at a subdomain:
 * <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
 */
export type CustomDomain = {
    metadata: CustomDomainMetadata;
    spec: CustomDomainSpec;
};

/**
 * Custom domain for preview deployments
 * The custom domain represents a base domain (e.g., example.com) that will be used
 * to serve preview deployments. Each preview will be accessible at a subdomain:
 * <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
 */
export type CustomDomainWritable = {
    metadata: CustomDomainMetadataWritable;
    spec: CustomDomainSpec;
};

/**
 * Custom domain metadata
 */
export type CustomDomainMetadata = TimeFields & OwnerFields & {
    /**
     * Display name for the custom domain
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Domain name (e.g., "example.com")
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Custom domain metadata
 */
export type CustomDomainMetadataWritable = TimeFields & OwnerFields & {
    /**
     * Display name for the custom domain
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Domain name (e.g., "example.com")
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Custom domain specification
 */
export type CustomDomainSpec = {
    /**
     * CNAME target for the domain
     */
    cnameRecords?: string;
    /**
     * Last verification attempt timestamp
     */
    lastVerifiedAt?: string;
    /**
     * Region that the custom domain is associated with
     */
    region?: string;
    /**
     * Current status of the domain (pending, verified, failed)
     */
    status?: 'pending' | 'verified' | 'failed';
    /**
     * Map of TXT record names to values for domain verification
     */
    txtRecords?: {
        [key: string]: string;
    };
    /**
     * Error message if verification failed
     */
    verificationError?: string;
};

/**
 * Entrypoint of the artifact
 */
export type Entrypoint = {
    /**
     * Args of the entrypoint
     */
    args?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Command of the entrypoint
     */
    command?: string;
    /**
     * Env of the entrypoint
     */
    env?: {
        [key: string]: string;
    };
    /**
     * Super Gateway args of the entrypoint
     */
    superGatewayArgs?: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * Expiration policy for sandbox lifecycle management
 */
export type ExpirationPolicy = {
    /**
     * Action to take when policy is triggered
     */
    action?: string;
    /**
     * Type of expiration policy
     */
    type?: 'ttl-idle' | 'ttl-max-age' | 'date';
    /**
     * Duration value (e.g., '1h', '24h', '7d')
     */
    value?: string;
};

/**
 * A type of hardware available for deployments
 */
export type Flavor = {
    /**
     * Flavor name (e.g. t4)
     */
    name?: string;
    /**
     * Flavor type (e.g. cpu, gpu)
     */
    type?: 'cpu' | 'gpu';
};

/**
 * Types of hardware available for deployments
 */
export type Flavors = Array<Flavor>;

/**
 * Form of the artifact
 */
export type Form = {
    /**
     * Config of the artifact
     */
    config?: {
        [key: string]: unknown;
    };
    oauth?: OAuth;
    /**
     * Secrets of the artifact
     */
    secrets?: {
        [key: string]: unknown;
    };
};

/**
 * Function
 */
export type _Function = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: FunctionSpec;
    status?: Status;
};

/**
 * Function
 */
export type FunctionWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: FunctionSpec;
    status?: Status;
};

/**
 * Runtime configuration for Function
 */
export type FunctionRuntime = {
    /**
     * The env variables to set in the function. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The generation of the function
     */
    generation?: 'mk2' | 'mk3';
    /**
     * The Docker image for the function
     */
    image?: string;
    /**
     * The maximum number of replicas for the function.
     */
    maxScale?: number;
    /**
     * The memory for the function in MB
     */
    memory?: number;
    /**
     * The minimum number of replicas for the function. Can be 0 or 1 (in which case the function is always running in at least one location).
     */
    minScale?: number;
};

/**
 * Function specification for API
 */
export type FunctionSpec = {
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    revision?: RevisionConfiguration;
    runtime?: FunctionRuntime;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: 'websocket' | 'http-stream';
    triggers?: Triggers;
};

/**
 * Histogram bucket
 */
export type HistogramBucket = {
    /**
     * Count
     */
    count?: number;
    /**
     * End
     */
    end?: number;
    /**
     * Start
     */
    start?: number;
};

/**
 * Histogram stats
 */
export type HistogramStats = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
};

export type Image = {
    metadata: ImageMetadata;
    spec: ImageSpec;
};

export type ImageMetadata = {
    /**
     * The date and time when the image was created.
     */
    createdAt?: string;
    /**
     * The display name of the image (registry/workspace/repository).
     */
    displayName?: string;
    /**
     * The date and time when the image was last deployed (most recent across all tags).
     */
    lastDeployedAt?: string;
    /**
     * The name of the image (repository name).
     */
    name?: string;
    /**
     * The resource type of the image.
     */
    resourceType?: string;
    /**
     * The date and time when the image was last updated.
     */
    updatedAt?: string;
    /**
     * The workspace of the image.
     */
    workspace?: string;
};

export type ImageSpec = {
    /**
     * The size of the image in bytes.
     */
    size?: number;
    /**
     * List of tags available for this image.
     */
    tags?: Array<ImageTag>;
};

export type ImageTag = {
    /**
     * The date and time when the tag was created.
     */
    createdAt?: string;
    /**
     * The name of the tag.
     */
    name?: string;
    /**
     * The size of the image in bytes.
     */
    size?: number;
    /**
     * The date and time when the tag was last updated.
     */
    updatedAt?: string;
};

/**
 * Integration
 */
export type Integration = {
    /**
     * Integration additional infos
     */
    additionalInfos?: {
        [key: string]: string;
    };
    endpoints?: IntegrationEndpoints;
    headers?: IntegrationHeaders;
    /**
     * Integration name
     */
    name?: string;
    /**
     * Integration organizations
     */
    organizations?: Array<IntegrationOrganization>;
    params?: IntegrationQueryParams;
    /**
     * Integration repositories
     */
    repositories?: Array<IntegrationRepository>;
};

/**
 * Integration Connection
 */
export type IntegrationConnection = {
    metadata: Metadata;
    spec: IntegrationConnectionSpec;
};

/**
 * Integration Connection
 */
export type IntegrationConnectionWritable = {
    metadata: MetadataWritable;
    spec: IntegrationConnectionSpec;
};

/**
 * Integration connection specification
 */
export type IntegrationConnectionSpec = {
    /**
     * Additional configuration for the integration
     */
    config?: {
        [key: string]: string;
    };
    /**
     * Integration type
     */
    integration?: string;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Integration secret
     */
    secret?: {
        [key: string]: string;
    };
};

export type IntegrationConnectionsList = Array<string>;

/**
 * Integration endpoint
 */
export type IntegrationEndpoint = {
    /**
     * Integration endpoint body
     */
    body?: string;
    /**
     * Integration endpoint ignore models
     */
    ignoreModels?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Integration endpoint method
     */
    method?: string;
    /**
     * Integration endpoint models
     */
    models?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Integration endpoint stream key
     */
    streamKey?: string;
    streamToken?: IntegrationEndpointToken;
    token?: IntegrationEndpointToken;
};

/**
 * Integration endpoint token
 */
export type IntegrationEndpointToken = {
    /**
     * Integration endpoint token received
     */
    received?: string;
    /**
     * Integration endpoint token sent
     */
    sent?: string;
    /**
     * Integration endpoint token total
     */
    total?: string;
};

/**
 * Integration endpoints
 */
export type IntegrationEndpoints = {
    [key: string]: IntegrationEndpoint;
};

/**
 * Integration headers
 */
export type IntegrationHeaders = {
    [key: string]: string;
};

/**
 * Integration organization
 */
export type IntegrationOrganization = {
    /**
     * Provider organization avatar URL
     */
    avatar_url?: string;
    /**
     * Provider organization display name
     */
    displayName?: string;
    /**
     * Provider organization ID
     */
    id?: string;
    /**
     * Provider organization name
     */
    name?: string;
};

/**
 * Integration query params
 */
export type IntegrationQueryParams = {
    [key: string]: string;
};

/**
 * Integration repository
 */
export type IntegrationRepository = {
    /**
     * Repository ID
     */
    id?: string;
    /**
     * Whether the repository has Blaxel imports
     */
    isBl?: boolean;
    /**
     * Repository name
     */
    name?: string;
    /**
     * Repository owner
     */
    organization?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Job
 */
export type Job = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: JobSpec;
    status?: Status;
};

/**
 * Job
 */
export type JobWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: JobSpec;
    status?: Status;
};

/**
 * Job execution
 */
export type JobExecution = {
    metadata: JobExecutionMetadata;
    spec: JobExecutionSpec;
    stats?: JobExecutionStats;
    status?: JobExecutionStatus;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTask>;
};

/**
 * Job execution metadata
 */
export type JobExecutionMetadata = {
    /**
     * Cluster ID
     */
    cluster?: string;
    /**
     * Completion timestamp
     */
    completedAt?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
    /**
     * Deletion timestamp
     */
    deletedAt?: string;
    /**
     * Expiration timestamp
     */
    expiredAt?: string;
    /**
     * Execution ID
     */
    id?: string;
    /**
     * Job name
     */
    job?: string;
    /**
     * Start timestamp
     */
    startedAt?: string;
    /**
     * Last update timestamp
     */
    updatedAt?: string;
    /**
     * Workspace ID
     */
    workspace?: string;
};

/**
 * Job execution specification
 */
export type JobExecutionSpec = {
    /**
     * Number of parallel tasks
     */
    parallelism?: number;
    /**
     * List of execution tasks
     */
    tasks?: Array<JobExecutionTask>;
    /**
     * Job timeout in seconds (captured at execution creation time)
     */
    timeout?: number;
};

/**
 * Job execution statistics
 */
export type JobExecutionStats = {
    /**
     * Number of cancelled tasks
     */
    cancelled?: number;
    /**
     * Number of failed tasks
     */
    failure?: number;
    /**
     * Number of retried tasks
     */
    retried?: number;
    /**
     * Number of running tasks
     */
    running?: number;
    /**
     * Number of successful tasks
     */
    success?: number;
    /**
     * Total number of tasks
     */
    total?: number;
};

/**
 * Job execution status
 */
export type JobExecutionStatus = 'queued' | 'pending' | 'running' | 'cancelling' | 'cancelled' | 'failed' | 'succeeded' | 'timeout';

/**
 * Job execution task
 */
export type JobExecutionTask = {
    /**
     * Task conditions
     */
    conditions?: Array<JobExecutionTaskCondition>;
    metadata?: JobExecutionTaskMetadata;
    spec?: JobExecutionTaskSpec;
    status?: JobExecutionTaskStatus;
};

/**
 * Job execution task condition
 */
export type JobExecutionTaskCondition = {
    /**
     * Execution reason
     */
    executionReason?: string;
    /**
     * Condition message
     */
    message?: string;
    /**
     * Condition reason
     */
    reason?: string;
    /**
     * Condition severity
     */
    severity?: string;
    /**
     * Condition state
     */
    state?: string;
    /**
     * Condition type
     */
    type?: string;
};

/**
 * Job execution task metadata
 */
export type JobExecutionTaskMetadata = {
    /**
     * Completion timestamp
     */
    completedAt?: string;
    /**
     * Creation timestamp
     */
    createdAt?: string;
    /**
     * Task name
     */
    name?: string;
    /**
     * Scheduled timestamp
     */
    scheduledAt?: string;
    /**
     * Start timestamp
     */
    startedAt?: string;
    /**
     * Last update timestamp
     */
    updatedAt?: string;
};

/**
 * Job execution task specification
 */
export type JobExecutionTaskSpec = {
    /**
     * Maximum number of retries
     */
    maxRetries?: number;
    /**
     * Task timeout duration
     */
    timeout?: string;
};

/**
 * Job execution task status
 */
export type JobExecutionTaskStatus = 'unspecified' | 'pending' | 'reconciling' | 'failed' | 'succeeded' | 'running' | 'cancelled';

/**
 * Runtime configuration for Job
 */
export type JobRuntime = {
    /**
     * The env variables to set in the job. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The generation of the job
     */
    generation?: 'mk2' | 'mk3';
    /**
     * The Docker image for the job
     */
    image?: string;
    /**
     * The maximum number of concurrent task for an execution
     */
    maxConcurrentTasks?: number;
    /**
     * The maximum number of retries for the job
     */
    maxRetries?: number;
    /**
     * The memory for the job in MB
     */
    memory?: number;
    ports?: Ports;
    /**
     * The timeout for the job in seconds
     */
    timeout?: number;
};

/**
 * Job specification for API
 */
export type JobSpec = {
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    policies?: PoliciesList;
    /**
     * Region where the job should be created (e.g. us-was-1, eu-lon-1)
     */
    region?: string;
    revision?: RevisionConfiguration;
    runtime?: JobRuntime;
    triggers?: Triggers;
};

/**
 * Jobs CPU usage
 */
export type JobsChartValue = {
    /**
     * Metric timestamp
     */
    timestamp?: string;
    /**
     * Metric value
     */
    value?: number;
};

/**
 * Jobs chart
 */
export type JobsSuccessFailedChart = {
    failed?: JobsChartValue;
    retried?: JobsChartValue;
    success?: JobsChartValue;
    /**
     * Metric timestamp
     */
    timestamp?: string;
    total?: JobsChartValue;
};

/**
 * Jobs executions
 */
export type JobsTotal = {
    /**
     * Failed executions
     */
    failed?: number;
    /**
     * Running executions
     */
    running?: number;
    /**
     * Success executions
     */
    success?: number;
    /**
     * Total executions
     */
    total?: number;
};

/**
 * Last N requests
 */
export type LastNRequestsMetric = {
    /**
     * Timestamp
     */
    date?: string;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Latency metrics
 */
export type LatencyMetric = {
    /**
     * Global histogram
     */
    globalHistogram?: Array<HistogramBucket>;
    globalStats?: HistogramStats;
    histogramPerCode?: HistogramBucket;
    statsPerCode?: HistogramStats;
};

/**
 * Location availability for policies
 */
export type LocationResponse = {
    /**
     * Continent of the location
     */
    continent?: string;
    /**
     * Country of the location
     */
    country?: string;
    /**
     * Hardware flavors available in the location
     */
    flavors?: Array<Flavor>;
    /**
     * Name of the location
     */
    location?: string;
    /**
     * Region of the location
     */
    region?: string;
    /**
     * Status of the location
     */
    status?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinition = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    entrypoint?: Entrypoint;
    form?: Form;
    /**
     * If the artifact is hidden
     */
    hidden?: boolean;
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinitionWritable = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    entrypoint?: Entrypoint;
    form?: Form;
    /**
     * If the artifact is hidden
     */
    hidden?: boolean;
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * Transport compatibility for the MCP, can be "websocket" or "http-stream"
     */
    transport?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Metrics for memory allocation
 */
export type MemoryAllocationMetric = {
    /**
     * Total memory allocation in GB-seconds
     */
    totalAllocation?: number;
};

/**
 * Metadata
 */
export type Metadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Model name
     */
    name: string;
    /**
     * Plan
     */
    readonly plan?: string;
    /**
     * URL
     */
    readonly url?: string;
    /**
     * Workspace name
     */
    readonly workspace?: string;
};

/**
 * Metadata
 */
export type MetadataWritable = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Model name
     */
    name: string;
};

/**
 * Labels
 */
export type MetadataLabels = {
    [key: string]: string;
};

/**
 * Metric
 */
export type Metric = {
    /**
     * Metric value
     */
    rate?: number;
    /**
     * Metric value
     */
    requestTotal?: number;
    /**
     * Metric timestamp
     */
    timestamp?: string;
};

/**
 * Logical object representing a model
 */
export type Model = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: ModelSpec;
    status?: Status;
};

/**
 * Logical object representing a model
 */
export type ModelWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: ModelSpec;
    status?: Status;
};

/**
 * Runtime configuration for Model
 */
export type ModelRuntime = {
    /**
     * Endpoint Name of the model. In case of hf_private_endpoint, it is the endpoint name. In case of hf_public_endpoint, it is not used.
     */
    endpointName?: string;
    /**
     * The slug name of the origin model at HuggingFace.
     */
    model?: string;
    /**
     * The organization of the model
     */
    organization?: string;
    /**
     * The type of origin for the deployment
     */
    type?: 'hf_private_endpoint' | 'hf_public_endpoint' | 'huggingface' | 'public_model' | 'mcp' | 'openai' | 'anthropic' | 'gemini' | 'mistral' | 'deepseek' | 'cohere' | 'cerebras' | 'xai' | 'vertexai' | 'azure-openai-service' | 'azure-ai-inference' | 'azure-marketplace' | 'groq';
};

/**
 * Model specification for API
 */
export type ModelSpec = {
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    flavors?: Flavors;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    runtime?: ModelRuntime;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
};

/**
 * OAuth of the artifact
 */
export type OAuth = {
    /**
     * Scope of the OAuth
     */
    scope?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Type of the OAuth
     */
    type?: string;
};

/**
 * Owner fields for Persistance
 */
export type OwnerFields = {
    /**
     * The user or service account who created the resource
     */
    readonly createdBy?: string;
    /**
     * The user or service account who updated the resource
     */
    readonly updatedBy?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitation = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationWritable = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAccept = {
    /**
     * User email
     */
    email?: string;
    workspace?: Workspace;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAcceptWritable = {
    /**
     * User email
     */
    email?: string;
    workspace?: WorkspaceWritable;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationRender = {
    /**
     * User email
     */
    email?: string;
    /**
     * Invitation date
     */
    invitedAt?: string;
    invitedBy?: PendingInvitationRenderInvitedBy;
    /**
     * ACL role
     */
    role?: string;
    workspace?: PendingInvitationRenderWorkspace;
    workspaceDetails?: PendingInvitationWorkspaceDetails;
};

/**
 * Invited by
 */
export type PendingInvitationRenderInvitedBy = {
    /**
     * User email
     */
    email?: string;
    /**
     * User family name
     */
    family_name?: string;
    /**
     * User given name
     */
    given_name?: string;
    /**
     * User sub
     */
    sub?: string;
};

/**
 * Workspace
 */
export type PendingInvitationRenderWorkspace = {
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Workspace name
     */
    name?: string;
};

/**
 * Workspace details
 */
export type PendingInvitationWorkspaceDetails = {
    /**
     * List of user emails in the workspace
     */
    emails?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Number of users in the workspace
     */
    user_number?: number;
};

export type Policies = Array<Policy>;

export type PoliciesWritable = Array<PolicyWritable>;

export type PoliciesList = Array<string>;

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type Policy = {
    metadata: Metadata;
    spec: PolicySpec;
};

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type PolicyWritable = {
    metadata: MetadataWritable;
    spec: PolicySpec;
};

/**
 * Policy location
 */
export type PolicyLocation = {
    /**
     * Policy location name
     */
    name?: string;
    /**
     * Policy location type
     */
    type?: 'location' | 'country' | 'continent';
};

/**
 * PolicyLocations is a local type that wraps a slice of Location
 */
export type PolicyLocations = Array<PolicyLocation>;

/**
 * PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
 */
export type PolicyMaxTokens = {
    /**
     * Granularity
     */
    granularity?: string;
    /**
     * Input
     */
    input?: number;
    /**
     * Output
     */
    output?: number;
    /**
     * RatioInputOverOutput
     */
    ratioInputOverOutput?: number;
    /**
     * Step
     */
    step?: number;
    /**
     * Total
     */
    total?: number;
};

/**
 * PolicyResourceType is a type of resource, e.g. model, function, etc.
 */
export type PolicyResourceType = 'model' | 'function' | 'agent' | 'sandbox';

/**
 * PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
 */
export type PolicyResourceTypes = Array<PolicyResourceType>;

/**
 * Policy specification
 */
export type PolicySpec = {
    flavors?: Flavors;
    locations?: PolicyLocations;
    maxTokens?: PolicyMaxTokens;
    resourceTypes?: PolicyResourceTypes;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Policy type, can be location or flavor
     */
    type?: 'location' | 'flavor' | 'maxToken';
};

/**
 * A port for a resource
 */
export type Port = {
    /**
     * The name of the port
     */
    name?: string;
    /**
     * The protocol of the port
     */
    protocol?: 'HTTP' | 'TCP' | 'UDP';
    /**
     * The target port of the port
     */
    target?: number;
};

/**
 * Set of ports for a resource
 */
export type Ports = Array<Port>;

/**
 * Preview of a Resource
 */
export type Preview = {
    metadata: PreviewMetadata;
    spec: PreviewSpec;
};

/**
 * Preview of a Resource
 */
export type PreviewWritable = {
    metadata: PreviewMetadataWritable;
    spec: PreviewSpec;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadataWritable = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Preview of a Resource
 */
export type PreviewSpec = {
    /**
     * Custom domain bound to this preview
     */
    customDomain?: string;
    /**
     * The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * Port of the preview
     */
    port?: number;
    /**
     * Prefix URL
     */
    prefixUrl?: string;
    /**
     * Whether the preview is public
     */
    public?: boolean;
    /**
     * Region where the preview is deployed, this is readonly
     */
    region?: string;
    /**
     * Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
     */
    requestHeaders?: {
        [key: string]: string;
    };
    /**
     * Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
     */
    responseHeaders?: {
        [key: string]: string;
    };
    /**
     * Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
     */
    ttl?: string;
    /**
     * URL of the preview
     */
    url?: string;
};

/**
 * Token for a Preview
 */
export type PreviewToken = {
    metadata: PreviewTokenMetadata;
    spec: PreviewTokenSpec;
};

/**
 * PreviewTokenMetadata
 */
export type PreviewTokenMetadata = {
    /**
     * Token name
     */
    name: string;
    /**
     * Preview name
     */
    previewName?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Spec for a Preview Token
 */
export type PreviewTokenSpec = {
    /**
     * Whether the token is expired
     */
    expired?: boolean;
    /**
     * Expiration time of the token
     */
    expiresAt?: string;
    /**
     * Token
     */
    token?: string;
};

/**
 * Private location available for policies
 */
export type PrivateLocation = {
    /**
     * Location name
     */
    name?: string;
};

export type PublicIp = {
    /**
     * Description of the region/location
     */
    description?: string;
    /**
     * List of public ipv4 addresses
     */
    ipv4Cidrs?: Array<string>;
    /**
     * List of public ipv6 addresses
     */
    ipv6Cidrs?: Array<string>;
};

export type PublicIps = {
    [key: string]: PublicIp;
};

/**
 * Region
 */
export type Region = {
    /**
     * Region display name
     */
    allowed?: string;
    /**
     * Region display name
     */
    continent?: string;
    /**
     * Region display name
     */
    country?: string;
    /**
     * Region display name
     */
    infoGeneration?: string;
    /**
     * Region display name
     */
    location?: string;
    /**
     * Region name
     */
    name?: string;
};

/**
 * Repository
 */
export type Repository = {
    /**
     * Repository type
     */
    type?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Request duration over time metric
 */
export type RequestDurationOverTimeMetric = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
    /**
     * Timestamp
     */
    timestamp?: string;
};

/**
 * Request duration over time metrics
 */
export type RequestDurationOverTimeMetrics = {
    /**
     * Request duration over time
     */
    requestDurationOverTime?: Array<RequestDurationOverTimeMetric>;
};

/**
 * Request total by origin metric
 */
export type RequestTotalByOriginMetric = {
    /**
     * Request total by origin
     */
    requestTotalByOrigin?: {
        [key: string]: unknown;
    };
    /**
     * Request total by origin and code
     */
    requestTotalByOriginAndCode?: {
        [key: string]: unknown;
    };
};

/**
 * Request total response data
 */
export type RequestTotalResponseData = {
    /**
     * Request total
     */
    requestTotal?: number;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Revision configuration
 */
export type RevisionConfiguration = {
    /**
     * Active revision id
     */
    active?: string;
    /**
     * Canary revision id
     */
    canary?: string;
    /**
     * Canary revision percent
     */
    canaryPercent?: number;
    /**
     * Sticky session TTL in seconds (0 = disabled)
     */
    stickySessionTtl?: number;
    /**
     * Traffic percentage
     */
    traffic?: number;
};

/**
 * Revision metadata
 */
export type RevisionMetadata = {
    /**
     * Is the revision active
     */
    active?: boolean;
    /**
     * Is the revision canary
     */
    canary?: boolean;
    /**
     * Revision created at
     */
    createdAt?: string;
    /**
     * Revision created by
     */
    createdBy?: string;
    /**
     * Revision ID
     */
    id?: string;
    /**
     * Is the revision previous active
     */
    previousActive?: boolean;
    /**
     * Status of the revision
     */
    status?: string;
    /**
     * Percent of traffic to the revision
     */
    trafficPercent?: number;
};

/**
 * Micro VM for running agentic tasks
 */
export type Sandbox = {
    events?: CoreEvents;
    /**
     * Last time the sandbox was used (read-only, managed by the system)
     */
    readonly lastUsedAt?: string;
    metadata: Metadata;
    spec: SandboxSpec;
    status?: Status;
};

/**
 * Micro VM for running agentic tasks
 */
export type SandboxWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: SandboxSpec;
    status?: Status;
};

/**
 * Sandbox definition for admin store operations
 */
export type SandboxDefinition = {
    /**
     * Categories of the defintion
     */
    categories?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * If the definition is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the defintion
     */
    description?: string;
    /**
     * Display name of the definition
     */
    displayName?: string;
    /**
     * If the definition is enterprise
     */
    enterprise?: boolean;
    /**
     * If the definition is hidden
     */
    hidden?: boolean;
    /**
     * Icon of the definition
     */
    icon?: string;
    /**
     * Image of the Sandbox definition
     */
    image?: string;
    /**
     * Long description of the defintion
     */
    longDescription?: string;
    /**
     * Memory of the Sandbox definition in MB
     */
    memory?: number;
    /**
     * Name of the artifact
     */
    name?: string;
    ports?: Ports;
    /**
     * Tags of the definition
     */
    tags?: string;
    /**
     * URL of the definition
     */
    url?: string;
};

/**
 * Lifecycle configuration for sandbox management
 */
export type SandboxLifecycle = {
    /**
     * List of expiration policies
     */
    expirationPolicies?: Array<ExpirationPolicy>;
};

/**
 * Enhanced sandbox metrics with memory, value, and percent data
 */
export type SandboxMetrics = {
    /**
     * Memory limit in bytes (from query A)
     */
    memory?: number;
    /**
     * Memory usage percentage (from formula F1)
     */
    percent?: number;
    /**
     * Metric timestamp
     */
    timestamp?: string;
    /**
     * Memory usage in bytes (from query B)
     */
    value?: number;
};

/**
 * Runtime configuration for Sandbox
 */
export type SandboxRuntime = {
    /**
     * The env variables to set in the sandbox. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The expiration date for the sandbox in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * The Docker image for the sandbox
     */
    image?: string;
    /**
     * The memory for the sandbox in MB
     */
    memory?: number;
    ports?: Ports;
    /**
     * The TTL for the sandbox in seconds - 30m, 24h, 7d
     */
    ttl?: string;
};

/**
 * Sandbox specification for API
 */
export type SandboxSpec = {
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    lifecycle?: SandboxLifecycle;
    /**
     * Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1)
     */
    region?: string;
    runtime?: SandboxRuntime;
    volumes?: VolumeAttachments;
};

/**
 * Status of a resource
 */
export type Status = 'DELETING' | 'TERMINATED' | 'FAILED' | 'DEACTIVATED' | 'DEACTIVATING' | 'UPLOADING' | 'BUILDING' | 'DEPLOYING' | 'DEPLOYED';

/**
 * Store configuration for resources (eg: agent, function, etc)
 */
export type StoreConfiguration = {
    /**
     * Available models for the configuration
     */
    availableModels?: Array<string>;
    /**
     * Store configuration description
     */
    description?: string;
    /**
     * Store configuration display name
     */
    displayName?: string;
    /**
     * Conditional rendering for the configuration, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration name
     */
    name?: string;
    options?: Array<StoreConfigurationOption>;
    /**
     * Store configuration required
     */
    required?: boolean;
    /**
     * Store configuration secret
     */
    secret?: boolean;
    /**
     * Store configuration type
     */
    type?: string;
};

/**
 * Store configuration options for a select type configuration
 */
export type StoreConfigurationOption = {
    /**
     * Conditional rendering for the configuration option, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration option label
     */
    label?: string;
    /**
     * Store configuration option value
     */
    value?: string;
};

/**
 * Blaxel template
 */
export type Template = {
    /**
     * Default branch of the template
     */
    defaultBranch?: string;
    /**
     * Description of the template
     */
    description?: string;
    /**
     * Number of downloads/clones of the repository
     */
    downloadCount?: number;
    /**
     * Number of forks the repository has
     */
    forksCount?: number;
    /**
     * URL to the template's icon
     */
    icon?: string;
    /**
     * URL to the template's icon in dark mode
     */
    iconDark?: string;
    /**
     * Name of the template
     */
    name?: string;
    /**
     * SHA of the variable
     */
    sha?: string;
    /**
     * Number of stars the repository has
     */
    starCount?: number;
    /**
     * Topic of the template
     */
    topics?: Array<string>;
    /**
     * URL of the template
     */
    url?: string;
    /**
     * Variables of the template
     */
    variables?: Array<TemplateVariable>;
};

/**
 * Blaxel template variable
 */
export type TemplateVariable = {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Integration of the variable
     */
    integration?: string;
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Path of the variable
     */
    path?: string;
    /**
     * Whether the variable is secret
     */
    secret?: boolean;
};

/**
 * Time fields for Persistance
 */
export type TimeFields = {
    /**
     * The date and time when the resource was created
     */
    readonly createdAt?: string;
    /**
     * The date and time when the resource was updated
     */
    readonly updatedAt?: string;
};

/**
 * Time to first token over time metrics
 */
export type TimeToFirstTokenOverTimeMetrics = {
    /**
     * Time to first token over time
     */
    timeToFirstTokenOverTime?: Array<RequestDurationOverTimeMetric>;
};

/**
 * Token rate metric
 */
export type TokenRateMetric = {
    /**
     * Model ID
     */
    model?: string;
    /**
     * Provider name
     */
    provider?: string;
    /**
     * Provider integration name
     */
    providerName?: string;
    /**
     * Timestamp
     */
    timestamp?: string;
    /**
     * Total tokens
     */
    tokenTotal?: number;
    /**
     * Trend
     */
    trend?: number;
};

/**
 * Token rate metrics
 */
export type TokenRateMetrics = {
    /**
     * Token rate
     */
    tokenRate?: Array<TokenRateMetric>;
    /**
     * Token rate input
     */
    tokenRateInput?: Array<TokenRateMetric>;
    /**
     * Token rate output
     */
    tokenRateOutput?: Array<TokenRateMetric>;
};

/**
 * Token total metric
 */
export type TokenTotalMetric = {
    /**
     * Average input token per request
     */
    averageTokenInputPerRequest?: number;
    /**
     * Average output token per request
     */
    averageTokenOutputPerRequest?: number;
    /**
     * Average token per request
     */
    averageTokenPerRequest?: number;
    /**
     * Total input tokens
     */
    tokenInput?: number;
    /**
     * Total output tokens
     */
    tokenOutput?: number;
    /**
     * Total tokens
     */
    tokenTotal?: number;
};

/**
 * Trigger configuration
 */
export type Trigger = {
    configuration?: TriggerConfiguration;
    /**
     * Enable or disable the trigger (default: true)
     */
    enabled?: boolean;
    /**
     * The id of the trigger
     */
    id?: string;
    /**
     * The type of trigger, can be http or http-async
     */
    type?: 'http' | 'http-async' | 'cron';
};

/**
 * Trigger configuration
 */
export type TriggerConfiguration = {
    /**
     * The authentication type of the trigger
     */
    authenticationType?: string;
    /**
     * The callback secret for async triggers (auto-generated, encrypted)
     */
    callbackSecret?: string;
    /**
     * The callback URL for async triggers (optional)
     */
    callbackUrl?: string;
    /**
     * The path of the trigger
     */
    path?: string;
    /**
     * The retry of the trigger
     */
    retry?: number;
    /**
     * The schedule of the trigger, cron expression * * * * *
     */
    schedule?: string;
    /**
     * The tasks configuration of the cronjob
     */
    tasks?: Array<TriggerConfigurationTask>;
    /**
     * The timeout in seconds for async triggers (max 900s, MK3 only)
     */
    timeout?: number;
};

/**
 * The tasks configuration of the cronjob
 */
export type TriggerConfigurationTask = {
    [key: string]: unknown;
};

/**
 * Triggers to use your agent
 */
export type Triggers = Array<Trigger>;

/**
 * Volume resource for persistent storage
 */
export type Volume = {
    events?: CoreEvents;
    metadata: Metadata;
    spec: VolumeSpec;
    state?: VolumeState;
    /**
     * Volume status computed from events
     */
    status?: string;
    /**
     * Timestamp when the volume was marked for termination
     */
    terminatedAt?: string;
};

/**
 * Volume resource for persistent storage
 */
export type VolumeWritable = {
    events?: CoreEvents;
    metadata: MetadataWritable;
    spec: VolumeSpec;
    state?: VolumeState;
    /**
     * Volume status computed from events
     */
    status?: string;
    /**
     * Timestamp when the volume was marked for termination
     */
    terminatedAt?: string;
};

/**
 * Volume attachment configuration for sandbox
 */
export type VolumeAttachment = {
    /**
     * Mount path in the container
     */
    mountPath?: string;
    /**
     * Name of the volume to attach
     */
    name?: string;
    /**
     * Whether the volume is mounted as read-only
     */
    readOnly?: boolean;
};

export type VolumeAttachments = Array<VolumeAttachment>;

/**
 * Volume specification - immutable configuration
 */
export type VolumeSpec = {
    /**
     * The internal infrastructure resource identifier for this volume
     */
    infrastructureId?: string;
    /**
     * Region where the volume should be created (e.g. us-pdx-1, eu-lon-1)
     */
    region?: string;
    /**
     * Size of the volume in MB
     */
    size?: number;
    /**
     * Volume template with revision (e.g. "mytemplate:1" or "mytemplate:latest")
     */
    template?: string;
};

/**
 * Volume state - mutable runtime state
 */
export type VolumeState = {
    /**
     * Resource this volume is attached to (e.g. "sandbox:my-sandbox", "model:my-model")
     */
    attachedTo?: string;
};

/**
 * Volume template for creating pre-configured volumes
 */
export type VolumeTemplate = {
    metadata: Metadata;
    spec: VolumeTemplateSpec;
    state?: VolumeTemplateState;
    /**
     * List of versions for this template
     */
    versions?: Array<VolumeTemplateVersion>;
};

/**
 * Volume template for creating pre-configured volumes
 */
export type VolumeTemplateWritable = {
    metadata: MetadataWritable;
    spec: VolumeTemplateSpec;
    state?: VolumeTemplateState;
    /**
     * List of versions for this template
     */
    versions?: Array<VolumeTemplateVersion>;
};

/**
 * Volume template specification
 */
export type VolumeTemplateSpec = {
    /**
     * Default size of the volume in MB
     */
    defaultSize?: number;
    /**
     * Description of the volume template
     */
    description?: string;
};

/**
 * Volume template state
 */
export type VolumeTemplateState = {
    /**
     * Timestamp of last version upload
     */
    lastVersionUploadedAt?: string;
    /**
     * Current/latest S3 version ID
     */
    latestVersion?: string;
    /**
     * Status of the volume template (created, ready, error)
     */
    status?: 'created' | 'ready' | 'error';
    /**
     * Total number of versions for this template
     */
    versionCount?: number;
};

/**
 * Volume template version tracking individual versions of template content
 */
export type VolumeTemplateVersion = {
    /**
     * S3 bucket name where this version is stored
     */
    bucket?: string;
    /**
     * Size of the template content in bytes
     */
    contentSize?: number;
    /**
     * Name of the template version
     */
    name?: string;
    /**
     * AWS region where this version is stored
     */
    region?: string;
    /**
     * Status of the version (CREATED, READY, FAILED)
     */
    status?: 'CREATED' | 'READY' | 'FAILED';
    /**
     * Template name this version belongs to
     */
    templateName?: string;
    /**
     * S3 version ID for this template version
     */
    versionId?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Workspace
 */
export type Workspace = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Autogenerated unique workspace id
     */
    id?: string;
    labels?: MetadataLabels;
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
    /**
     * Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
     */
    status?: 'created' | 'account_binded' | 'account_configured' | 'workspace_configured' | 'ready' | 'error';
    /**
     * Reason for current status (only set for error status)
     */
    statusReason?: string;
};

/**
 * Workspace
 */
export type WorkspaceWritable = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Autogenerated unique workspace id
     */
    id?: string;
    labels?: MetadataLabels;
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
    /**
     * Workspace status (created, account_binded, account_configured, workspace_configured, ready, error)
     */
    status?: 'created' | 'account_binded' | 'account_configured' | 'workspace_configured' | 'ready' | 'error';
    /**
     * Reason for current status (only set for error status)
     */
    statusReason?: string;
};

/**
 * Workspace runtime
 */
export type WorkspaceRuntime = {
    /**
     * Workspace generation
     */
    generation?: string;
};

/**
 * Workspace user
 */
export type WorkspaceUser = {
    /**
     * Whether the user has accepted the workspace invitation
     */
    accepted?: boolean;
    /**
     * Workspace user email
     */
    email?: string;
    /**
     * Whether the user's email has been verified
     */
    email_verified?: boolean;
    /**
     * Workspace user family name
     */
    family_name?: string;
    /**
     * Workspace user given name
     */
    given_name?: string;
    /**
     * Workspace user role
     */
    role?: string;
    /**
     * Workspace user identifier
     */
    sub?: string;
};

export type ListAgentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agents';
};

export type ListAgentsResponses = {
    /**
     * successful operation
     */
    200: Array<Agent>;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type CreateAgentData = {
    body: AgentWritable;
    path?: never;
    query?: never;
    url: '/agents';
};

export type CreateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type DeleteAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: {
        /**
         * Show secret values (admin only)
         */
        show_secrets?: boolean;
    };
    url: '/agents/{agentName}';
};

export type GetAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body: AgentWritable;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type UpdateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type ListAgentRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}/revisions';
};

export type ListAgentRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListAgentRevisionsResponse = ListAgentRevisionsResponses[keyof ListAgentRevisionsResponses];

export type GetConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/configuration';
};

export type GetConfigurationResponses = {
    /**
     * Configuration of the control plane
     */
    200: Configuration;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type ListCustomDomainsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type ListCustomDomainsResponses = {
    /**
     * successful operation
     */
    200: Array<CustomDomain>;
};

export type ListCustomDomainsResponse = ListCustomDomainsResponses[keyof ListCustomDomainsResponses];

export type CreateCustomDomainData = {
    body: CustomDomainWritable;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type CreateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type CreateCustomDomainResponse = CreateCustomDomainResponses[keyof CreateCustomDomainResponses];

export type DeleteCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type DeleteCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type DeleteCustomDomainResponse = DeleteCustomDomainResponses[keyof DeleteCustomDomainResponses];

export type GetCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type GetCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type GetCustomDomainResponse = GetCustomDomainResponses[keyof GetCustomDomainResponses];

export type UpdateCustomDomainData = {
    body: CustomDomainWritable;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type UpdateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type UpdateCustomDomainResponse = UpdateCustomDomainResponses[keyof UpdateCustomDomainResponses];

export type VerifyCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}/verify';
};

export type VerifyCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type VerifyCustomDomainResponse = VerifyCustomDomainResponses[keyof VerifyCustomDomainResponses];

export type ListFunctionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/functions';
};

export type ListFunctionsResponses = {
    /**
     * successful operation
     */
    200: Array<_Function>;
};

export type ListFunctionsResponse = ListFunctionsResponses[keyof ListFunctionsResponses];

export type CreateFunctionData = {
    body: FunctionWritable;
    path?: never;
    query?: never;
    url: '/functions';
};

export type CreateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type CreateFunctionResponse = CreateFunctionResponses[keyof CreateFunctionResponses];

export type DeleteFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type DeleteFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type DeleteFunctionResponse = DeleteFunctionResponses[keyof DeleteFunctionResponses];

export type GetFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: {
        /**
         * Show secret values (admin only)
         */
        show_secrets?: boolean;
    };
    url: '/functions/{functionName}';
};

export type GetFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type GetFunctionResponse = GetFunctionResponses[keyof GetFunctionResponses];

export type UpdateFunctionData = {
    body: FunctionWritable;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type UpdateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type UpdateFunctionResponse = UpdateFunctionResponses[keyof UpdateFunctionResponses];

export type ListFunctionRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}/revisions';
};

export type ListFunctionRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListFunctionRevisionsResponse = ListFunctionRevisionsResponses[keyof ListFunctionRevisionsResponses];

export type CleanupImagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/images';
};

export type CleanupImagesResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Number of images deleted
         */
        deleted?: number;
        /**
         * Result message
         */
        message?: string;
    };
};

export type CleanupImagesResponse = CleanupImagesResponses[keyof CleanupImagesResponses];

export type ListImagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/images';
};

export type ListImagesResponses = {
    /**
     * successful operation
     */
    200: Array<Image>;
};

export type ListImagesResponse = ListImagesResponses[keyof ListImagesResponses];

export type DeleteImageData = {
    body?: never;
    path: {
        /**
         * Resource type of the image
         */
        resourceType: string;
        /**
         * Name of the image
         */
        imageName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}';
};

export type DeleteImageErrors = {
    /**
     * image used
     */
    400: unknown;
    /**
     * image not found
     */
    404: unknown;
};

export type DeleteImageResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type DeleteImageResponse = DeleteImageResponses[keyof DeleteImageResponses];

export type GetImageData = {
    body?: never;
    path: {
        /**
         * Resource type of the image
         */
        resourceType: string;
        /**
         * Name of the image
         */
        imageName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}';
};

export type GetImageResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type GetImageResponse = GetImageResponses[keyof GetImageResponses];

export type DeleteImageTagData = {
    body?: never;
    path: {
        /**
         * Resource type of the image
         */
        resourceType: string;
        /**
         * Name of the image
         */
        imageName: string;
        /**
         * Name of the tag to delete
         */
        tagName: string;
    };
    query?: never;
    url: '/images/{resourceType}/{imageName}/tags/{tagName}';
};

export type DeleteImageTagErrors = {
    /**
     * tag is in use
     */
    400: unknown;
    /**
     * image or tag not found
     */
    404: unknown;
};

export type DeleteImageTagResponses = {
    /**
     * successful operation
     */
    200: Image;
};

export type DeleteImageTagResponse = DeleteImageTagResponses[keyof DeleteImageTagResponses];

export type GetIntegrationData = {
    body?: never;
    path: {
        /**
         * Name of the integration
         */
        integrationName: string;
    };
    query?: never;
    url: '/integrations/{integrationName}';
};

export type GetIntegrationResponses = {
    /**
     * successful operation
     */
    200: Integration;
};

export type GetIntegrationResponse = GetIntegrationResponses[keyof GetIntegrationResponses];

export type ListIntegrationConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type ListIntegrationConnectionsResponses = {
    /**
     * successful operation
     */
    200: Array<IntegrationConnection>;
};

export type ListIntegrationConnectionsResponse = ListIntegrationConnectionsResponses[keyof ListIntegrationConnectionsResponses];

export type CreateIntegrationConnectionData = {
    body: IntegrationConnectionWritable;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type CreateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type CreateIntegrationConnectionResponse = CreateIntegrationConnectionResponses[keyof CreateIntegrationConnectionResponses];

export type DeleteIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type DeleteIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type DeleteIntegrationConnectionResponse = DeleteIntegrationConnectionResponses[keyof DeleteIntegrationConnectionResponses];

export type GetIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type GetIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type GetIntegrationConnectionResponse = GetIntegrationConnectionResponses[keyof GetIntegrationConnectionResponses];

export type UpdateIntegrationConnectionData = {
    body: IntegrationConnectionWritable;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type UpdateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type UpdateIntegrationConnectionResponse = UpdateIntegrationConnectionResponses[keyof UpdateIntegrationConnectionResponses];

export type GetIntegrationConnectionModelEndpointConfigurationsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/endpointConfigurations';
};

export type GetIntegrationConnectionModelEndpointConfigurationsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListIntegrationConnectionModelsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models';
};

export type ListIntegrationConnectionModelsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetIntegrationConnectionModelData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
        /**
         * Model ID
         */
        modelId: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models/{modelId}';
};

export type GetIntegrationConnectionModelResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListJobsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type ListJobsResponses = {
    /**
     * successful operation
     */
    200: Array<Job>;
};

export type ListJobsResponse = ListJobsResponses[keyof ListJobsResponses];

export type CreateJobData = {
    body: JobWritable;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type CreateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type CreateJobResponse = CreateJobResponses[keyof CreateJobResponses];

export type DeleteJobData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type DeleteJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type DeleteJobResponse = DeleteJobResponses[keyof DeleteJobResponses];

export type GetJobData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: {
        /**
         * Show secret values (admin only)
         */
        show_secrets?: boolean;
    };
    url: '/jobs/{jobId}';
};

export type GetJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type GetJobResponse = GetJobResponses[keyof GetJobResponses];

export type UpdateJobData = {
    body: JobWritable;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type UpdateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];

export type ListJobExecutionsData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: {
        /**
         * Number of items per page
         */
        limit?: number;
        /**
         * Page offset
         */
        offset?: number;
    };
    url: '/jobs/{jobId}/executions';
};

export type ListJobExecutionsErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type ListJobExecutionsResponses = {
    /**
     * successful operation
     */
    200: Array<JobExecution>;
};

export type ListJobExecutionsResponse = ListJobExecutionsResponses[keyof ListJobExecutionsResponses];

export type CreateJobExecutionData = {
    body: CreateJobExecutionRequest;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions';
};

export type CreateJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type CreateJobExecutionResponses = {
    /**
     * successful operation
     */
    200: JobExecution;
};

export type CreateJobExecutionResponse = CreateJobExecutionResponses[keyof CreateJobExecutionResponses];

export type DeleteJobExecutionData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
        /**
         * Id of the execution
         */
        executionId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions/{executionId}';
};

export type DeleteJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * execution not found
     */
    404: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type DeleteJobExecutionResponses = {
    /**
     * successful operation
     */
    200: JobExecution;
};

export type DeleteJobExecutionResponse = DeleteJobExecutionResponses[keyof DeleteJobExecutionResponses];

export type GetJobExecutionData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
        /**
         * Id of the execution
         */
        executionId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/executions/{executionId}';
};

export type GetJobExecutionErrors = {
    /**
     * bad request
     */
    400: unknown;
    /**
     * execution not found
     */
    404: unknown;
    /**
     * internal server error
     */
    500: unknown;
};

export type GetJobExecutionResponses = {
    /**
     * successful operation
     */
    200: JobExecution;
};

export type GetJobExecutionResponse = GetJobExecutionResponses[keyof GetJobExecutionResponses];

export type ListJobRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/revisions';
};

export type ListJobRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListJobRevisionsResponse = ListJobRevisionsResponses[keyof ListJobRevisionsResponses];

export type ListLocationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/locations';
};

export type ListLocationsResponses = {
    /**
     * successful operation
     */
    200: Array<LocationResponse>;
};

export type ListLocationsResponse = ListLocationsResponses[keyof ListLocationsResponses];

export type ListMcpHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mcp/hub';
};

export type ListMcpHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<McpDefinition>;
};

export type ListMcpHubDefinitionsResponse = ListMcpHubDefinitionsResponses[keyof ListMcpHubDefinitionsResponses];

export type ListModelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/models';
};

export type ListModelsResponses = {
    /**
     * successful operation
     */
    200: Array<Model>;
};

export type ListModelsResponse = ListModelsResponses[keyof ListModelsResponses];

export type CreateModelData = {
    body: ModelWritable;
    path?: never;
    query?: never;
    url: '/models';
};

export type CreateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type CreateModelResponse = CreateModelResponses[keyof CreateModelResponses];

export type DeleteModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type DeleteModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type DeleteModelResponse = DeleteModelResponses[keyof DeleteModelResponses];

export type GetModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type GetModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type GetModelResponse = GetModelResponses[keyof GetModelResponses];

export type UpdateModelData = {
    body: ModelWritable;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type UpdateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type UpdateModelResponse = UpdateModelResponses[keyof UpdateModelResponses];

export type ListModelRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}/revisions';
};

export type ListModelRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListModelRevisionsResponse = ListModelRevisionsResponses[keyof ListModelRevisionsResponses];

export type ListPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/policies';
};

export type ListPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<Policy>;
};

export type ListPoliciesResponse = ListPoliciesResponses[keyof ListPoliciesResponses];

export type CreatePolicyData = {
    body: PolicyWritable;
    path?: never;
    query?: never;
    url: '/policies';
};

export type CreatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type CreatePolicyResponse = CreatePolicyResponses[keyof CreatePolicyResponses];

export type DeletePolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type DeletePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type DeletePolicyResponse = DeletePolicyResponses[keyof DeletePolicyResponses];

export type GetPolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type GetPolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type GetPolicyResponse = GetPolicyResponses[keyof GetPolicyResponses];

export type UpdatePolicyData = {
    body: PolicyWritable;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type UpdatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type UpdatePolicyResponse = UpdatePolicyResponses[keyof UpdatePolicyResponses];

export type ListAllPendingInvitationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/profile/invitations';
};

export type ListAllPendingInvitationsErrors = {
    /**
     * no pending invitations
     */
    404: unknown;
};

export type ListAllPendingInvitationsResponses = {
    /**
     * successful operation
     */
    200: Array<PendingInvitationRender>;
};

export type ListAllPendingInvitationsResponse = ListAllPendingInvitationsResponses[keyof ListAllPendingInvitationsResponses];

export type ListPublicIpsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by region name (only returns mk3 region data)
         */
        region?: string;
    };
    url: '/publicIps';
};

export type ListPublicIpsResponses = {
    /**
     * successful operation
     */
    200: PublicIps;
};

export type ListPublicIpsResponse = ListPublicIpsResponses[keyof ListPublicIpsResponses];

export type ListSandboxHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandbox/hub';
};

export type ListSandboxHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<SandboxDefinition>;
};

export type ListSandboxHubDefinitionsResponse = ListSandboxHubDefinitionsResponses[keyof ListSandboxHubDefinitionsResponses];

export type ListSandboxesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type ListSandboxesResponses = {
    /**
     * successful operation
     */
    200: Array<Sandbox>;
};

export type ListSandboxesResponse = ListSandboxesResponses[keyof ListSandboxesResponses];

export type CreateSandboxData = {
    body: SandboxWritable;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type CreateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type CreateSandboxResponse = CreateSandboxResponses[keyof CreateSandboxResponses];

export type DeleteSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type DeleteSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type DeleteSandboxResponse = DeleteSandboxResponses[keyof DeleteSandboxResponses];

export type GetSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: {
        /**
         * Show secret values (admin only)
         */
        show_secrets?: boolean;
    };
    url: '/sandboxes/{sandboxName}';
};

export type GetSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type GetSandboxResponse = GetSandboxResponses[keyof GetSandboxResponses];

export type UpdateSandboxData = {
    body: SandboxWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type UpdateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type UpdateSandboxResponse = UpdateSandboxResponses[keyof UpdateSandboxResponses];

export type ListSandboxPreviewsData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type ListSandboxPreviewsResponses = {
    /**
     * successful operation
     */
    200: Array<Preview>;
};

export type ListSandboxPreviewsResponse = ListSandboxPreviewsResponses[keyof ListSandboxPreviewsResponses];

export type CreateSandboxPreviewData = {
    body: PreviewWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type CreateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type CreateSandboxPreviewResponse = CreateSandboxPreviewResponses[keyof CreateSandboxPreviewResponses];

export type DeleteSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type DeleteSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type DeleteSandboxPreviewResponse = DeleteSandboxPreviewResponses[keyof DeleteSandboxPreviewResponses];

export type GetSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type GetSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type GetSandboxPreviewResponse = GetSandboxPreviewResponses[keyof GetSandboxPreviewResponses];

export type UpdateSandboxPreviewData = {
    body: PreviewWritable;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type UpdateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type UpdateSandboxPreviewResponse = UpdateSandboxPreviewResponses[keyof UpdateSandboxPreviewResponses];

export type ListSandboxPreviewTokensData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type ListSandboxPreviewTokensResponses = {
    /**
     * successful operation
     */
    200: Array<PreviewToken>;
};

export type ListSandboxPreviewTokensResponse = ListSandboxPreviewTokensResponses[keyof ListSandboxPreviewTokensResponses];

export type CreateSandboxPreviewTokenData = {
    body: PreviewToken;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type CreateSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: PreviewToken;
};

export type CreateSandboxPreviewTokenResponse = CreateSandboxPreviewTokenResponses[keyof CreateSandboxPreviewTokenResponses];

export type DeleteSandboxPreviewTokenData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
        /**
         * Name of the Token
         */
        tokenName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens/{tokenName}';
};

export type DeleteSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type DeleteSandboxPreviewTokenResponse = DeleteSandboxPreviewTokenResponses[keyof DeleteSandboxPreviewTokenResponses];

export type GetWorkspaceServiceAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type GetWorkspaceServiceAccountsResponses = {
    /**
     * successful operation
     */
    200: Array<{
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    }>;
};

export type GetWorkspaceServiceAccountsResponse = GetWorkspaceServiceAccountsResponses[keyof GetWorkspaceServiceAccountsResponses];

export type CreateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type CreateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Service account client secret (only returned on creation)
         */
        client_secret?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type CreateWorkspaceServiceAccountResponse = CreateWorkspaceServiceAccountResponses[keyof CreateWorkspaceServiceAccountResponses];

export type DeleteWorkspaceServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type DeleteWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type DeleteWorkspaceServiceAccountResponse = DeleteWorkspaceServiceAccountResponses[keyof DeleteWorkspaceServiceAccountResponses];

export type UpdateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type UpdateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type UpdateWorkspaceServiceAccountResponse = UpdateWorkspaceServiceAccountResponses[keyof UpdateWorkspaceServiceAccountResponses];

export type ListApiKeysForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type ListApiKeysForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: Array<ApiKey>;
};

export type ListApiKeysForServiceAccountResponse = ListApiKeysForServiceAccountResponses[keyof ListApiKeysForServiceAccountResponses];

export type CreateApiKeyForServiceAccountData = {
    body: {
        /**
         * Expiration period for the API key
         */
        expires_in?: string;
        /**
         * Name for the API key
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type CreateApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: ApiKey;
};

export type CreateApiKeyForServiceAccountResponse = CreateApiKeyForServiceAccountResponses[keyof CreateApiKeyForServiceAccountResponses];

export type DeleteApiKeyForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
        /**
         * Api key id
         */
        apiKeyId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys/{apiKeyId}';
};

export type DeleteApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/templates';
};

export type ListTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<Template>;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the template
         */
        templateName: string;
    };
    query?: never;
    url: '/templates/{templateName}';
};

export type GetTemplateResponses = {
    /**
     * successful operation
     */
    200: Template;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type ListWorkspaceUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/users';
};

export type ListWorkspaceUsersResponses = {
    /**
     * successful operation
     */
    200: Array<WorkspaceUser>;
};

export type ListWorkspaceUsersResponse = ListWorkspaceUsersResponses[keyof ListWorkspaceUsersResponses];

export type InviteWorkspaceUserData = {
    /**
     * Email of the user to invite
     */
    body: {
        email?: string;
    };
    path?: never;
    query?: never;
    url: '/users';
};

export type InviteWorkspaceUserErrors = {
    /**
     * invalid email format
     */
    400: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type InviteWorkspaceUserResponses = {
    /**
     * successful operation
     */
    200: PendingInvitation;
};

export type InviteWorkspaceUserResponse = InviteWorkspaceUserResponses[keyof InviteWorkspaceUserResponses];

export type RemoveWorkspaceUserData = {
    body?: never;
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type RemoveWorkspaceUserErrors = {
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type RemoveWorkspaceUserResponses = {
    /**
     * User successfully removed or invitation revoked
     */
    200: unknown;
};

export type UpdateWorkspaceUserRoleData = {
    body: {
        /**
         * The new role to assign to the user
         */
        role: string;
    };
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type UpdateWorkspaceUserRoleErrors = {
    /**
     * Invalid role provided
     */
    400: unknown;
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type UpdateWorkspaceUserRoleResponses = {
    /**
     * User role updated successfully
     */
    200: WorkspaceUser;
};

export type UpdateWorkspaceUserRoleResponse = UpdateWorkspaceUserRoleResponses[keyof UpdateWorkspaceUserRoleResponses];

export type ListVolumeTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/volume_templates';
};

export type ListVolumeTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<VolumeTemplate>;
};

export type ListVolumeTemplatesResponse = ListVolumeTemplatesResponses[keyof ListVolumeTemplatesResponses];

export type CreateVolumeTemplateData = {
    body: VolumeTemplateWritable;
    path?: never;
    query?: {
        /**
         * If true, returns a presigned URL for uploading the template content
         */
        upload?: boolean;
        /**
         * Version name for the template version being created
         */
        version?: string;
    };
    url: '/volume_templates';
};

export type CreateVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type CreateVolumeTemplateResponse = CreateVolumeTemplateResponses[keyof CreateVolumeTemplateResponses];

export type DeleteVolumeTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}';
};

export type DeleteVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type DeleteVolumeTemplateResponse = DeleteVolumeTemplateResponses[keyof DeleteVolumeTemplateResponses];

export type GetVolumeTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}';
};

export type GetVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type GetVolumeTemplateResponse = GetVolumeTemplateResponses[keyof GetVolumeTemplateResponses];

export type UpdateVolumeTemplateData = {
    body: VolumeTemplateWritable;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
    };
    query?: {
        /**
         * If true, returns a presigned URL for uploading the template content
         */
        upload?: boolean;
        /**
         * Version name for the template version being created
         */
        version?: string;
    };
    url: '/volume_templates/{volumeTemplateName}';
};

export type UpdateVolumeTemplateResponses = {
    /**
     * successful operation
     */
    200: VolumeTemplate;
};

export type UpdateVolumeTemplateResponse = UpdateVolumeTemplateResponses[keyof UpdateVolumeTemplateResponses];

export type DeleteVolumeTemplateVersionData = {
    body?: never;
    path: {
        /**
         * Name of the volume template
         */
        volumeTemplateName: string;
        /**
         * Name of the version to delete
         */
        versionName: string;
    };
    query?: never;
    url: '/volume_templates/{volumeTemplateName}/versions/{versionName}';
};

export type DeleteVolumeTemplateVersionErrors = {
    /**
     * Cannot delete the only version
     */
    400: unknown;
    /**
     * Version not found
     */
    404: unknown;
};

export type DeleteVolumeTemplateVersionResponses = {
    /**
     * Version deleted successfully
     */
    200: {
        message?: string;
        template?: VolumeTemplate;
    };
};

export type DeleteVolumeTemplateVersionResponse = DeleteVolumeTemplateVersionResponses[keyof DeleteVolumeTemplateVersionResponses];

export type ListVolumesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type ListVolumesResponses = {
    /**
     * successful operation
     */
    200: Array<Volume>;
};

export type ListVolumesResponse = ListVolumesResponses[keyof ListVolumesResponses];

export type CreateVolumeData = {
    body: VolumeWritable;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type CreateVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type CreateVolumeResponse = CreateVolumeResponses[keyof CreateVolumeResponses];

export type DeleteVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type DeleteVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type DeleteVolumeResponse = DeleteVolumeResponses[keyof DeleteVolumeResponses];

export type GetVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type GetVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type GetVolumeResponse = GetVolumeResponses[keyof GetVolumeResponses];

export type ListWorkspacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type ListWorkspacesResponses = {
    /**
     * successful operation
     */
    200: Array<Workspace>;
};

export type ListWorkspacesResponse = ListWorkspacesResponses[keyof ListWorkspacesResponses];

export type CreateWorkspaceData = {
    body: WorkspaceWritable;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type CreateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type CreateWorkspaceResponse = CreateWorkspaceResponses[keyof CreateWorkspaceResponses];

export type DeleteWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type DeleteWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type DeleteWorkspaceResponse = DeleteWorkspaceResponses[keyof DeleteWorkspaceResponses];

export type GetWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type GetWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type GetWorkspaceResponse = GetWorkspaceResponses[keyof GetWorkspaceResponses];

export type UpdateWorkspaceData = {
    body: WorkspaceWritable;
    path: {
        /**
         * name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type UpdateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type UpdateWorkspaceResponse = UpdateWorkspaceResponses[keyof UpdateWorkspaceResponses];

export type DeclineWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/decline';
};

export type DeclineWorkspaceInvitationResponses = {
    /**
     * Invitation successfully declined
     */
    200: PendingInvitation;
};

export type DeclineWorkspaceInvitationResponse = DeclineWorkspaceInvitationResponses[keyof DeclineWorkspaceInvitationResponses];

export type AcceptWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/join';
};

export type AcceptWorkspaceInvitationErrors = {
    /**
     * Workspace or invitation not found
     */
    404: unknown;
};

export type AcceptWorkspaceInvitationResponses = {
    /**
     * Invitation successfully accepted
     */
    200: PendingInvitationAccept;
};

export type AcceptWorkspaceInvitationResponse = AcceptWorkspaceInvitationResponses[keyof AcceptWorkspaceInvitationResponses];

export type LeaveWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/leave';
};

export type LeaveWorkspaceErrors = {
    /**
     * Workspace not found
     */
    404: unknown;
};

export type LeaveWorkspaceResponses = {
    /**
     * Workspace successfully left
     */
    200: Workspace;
};

export type LeaveWorkspaceResponse = LeaveWorkspaceResponses[keyof LeaveWorkspaceResponses];

export type CheckWorkspaceAvailabilityData = {
    body: {
        name: string;
    };
    path?: never;
    query?: never;
    url: '/workspaces/availability';
};

export type CheckWorkspaceAvailabilityResponses = {
    /**
     * successful operation
     */
    200: boolean;
};

export type CheckWorkspaceAvailabilityResponse = CheckWorkspaceAvailabilityResponses[keyof CheckWorkspaceAvailabilityResponses];

export type ClientOptions = {
    baseUrl: 'https://api.blaxel.ai/v0' | 'https://run.blaxel.ai' | (string & {});
};