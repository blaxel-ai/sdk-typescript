/* eslint-disable */
// This file is auto-generated by @hey-api/openapi-ts

/**
 * ACL
 */
export type Acl = TimeFields & {
    /**
     * ACL id
     */
    id?: string;
    /**
     * Resource ID
     */
    resource_id?: string;
    /**
     * Resource type
     */
    resource_type?: string;
    /**
     * Role
     */
    role?: string;
    /**
     * Subject ID
     */
    subject_id?: string;
    /**
     * Subject type
     */
    subject_type?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Agent
 */
export type Agent = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: AgentSpec;
    /**
     * Agent status
     */
    status?: string;
};

/**
 * Agent specification
 */
export type AgentSpec = CoreSpec & {
    /**
     * Description, small description computed from the prompt
     */
    description?: string;
    repository?: Repository;
    triggers?: Triggers;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKey = TimeFields & OwnerFields & {
    /**
     * Api key
     */
    apiKey?: string;
    /**
     * Duration until expiration (in seconds)
     */
    expires_in?: string;
    /**
     * Api key id, to retrieve it from the API
     */
    id?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * User subject identifier
     */
    sub?: string;
    /**
     * Subject type
     */
    sub_type?: string;
};

/**
 * Array of metrics
 */
export type ArrayMetric = Array<Metric>;

/**
 * Billable time metric
 */
export type BillableTimeMetric = {
    /**
     * Billable time
     */
    billableTime?: number;
    /**
     * Total memory allocation in GB-seconds
     */
    totalAllocation?: number;
};

/**
 * Configuration
 */
export type Configuration = {
    /**
     * Continents
     */
    continents?: Array<unknown>;
    /**
     * Countries
     */
    countries?: Array<unknown>;
    /**
     * Private locations managed with blaxel operator
     */
    privateLocations?: Array<unknown>;
};

/**
 * Continent
 */
export type Continent = {
    /**
     * Continent display name
     */
    displayName?: string;
    /**
     * Continent code
     */
    name?: string;
};

/**
 * Core event
 */
export type CoreEvent = {
    /**
     * Event message
     */
    message?: string;
    /**
     * RevisionID link to the event
     */
    revision?: string;
    /**
     * Event status
     */
    status?: string;
    /**
     * Event time
     */
    time?: string;
    /**
     * Event type
     */
    type?: string;
};

/**
 * Core events
 */
export type CoreEvents = Array<CoreEvent>;

/**
 * Core specification
 */
export type CoreSpec = {
    /**
     * Optional configurations for the object
     */
    configurations?: {
        key?: SpecConfiguration;
    };
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    flavors?: Flavors;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    privateClusters?: ModelPrivateCluster;
    revision?: RevisionConfiguration;
    runtime?: Runtime;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
};

/**
 * Configuration
 */
export type Country = {
    /**
     * Country display name
     */
    displayName?: string;
    /**
     * Country code
     */
    name?: string;
};

/**
 * Custom domain for preview deployments
 * The custom domain represents a base domain (e.g., example.com) that will be used
 * to serve preview deployments. Each preview will be accessible at a subdomain:
 * <preview-id>.preview.<base-domain> (e.g., abc123.preview.example.com)
 */
export type CustomDomain = {
    metadata?: CustomDomainMetadata;
    spec?: CustomDomainSpec;
};

/**
 * Custom domain metadata
 */
export type CustomDomainMetadata = TimeFields & OwnerFields & {
    /**
     * Display name for the custom domain
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Domain name (e.g., "example.com")
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Custom domain specification
 */
export type CustomDomainSpec = {
    /**
     * CNAME target for the domain
     */
    cnameRecords?: string;
    /**
     * Last verification attempt timestamp
     */
    lastVerifiedAt?: string;
    /**
     * Region that the custom domain is associated with
     */
    region?: string;
    /**
     * Current status of the domain (pending, verified, failed)
     */
    status?: string;
    /**
     * Map of TXT record names to values for domain verification
     */
    txtRecords?: {
        [key: string]: string;
    };
    /**
     * Error message if verification failed
     */
    verificationError?: string;
};

/**
 * Entrypoint of the artifact
 */
export type Entrypoint = {
    /**
     * Args of the entrypoint
     */
    args?: Array<unknown>;
    /**
     * Command of the entrypoint
     */
    command?: string;
    /**
     * Env of the entrypoint
     */
    env?: {
        [key: string]: unknown;
    };
    /**
     * Super Gateway args of the entrypoint
     */
    superGatewayArgs?: Array<unknown>;
};

/**
 * A type of hardware available for deployments
 */
export type Flavor = {
    /**
     * Flavor name (e.g. t4)
     */
    name?: string;
    /**
     * Flavor type (e.g. cpu, gpu)
     */
    type?: string;
};

/**
 * Types of hardware available for deployments
 */
export type Flavors = Array<Flavor>;

/**
 * Form of the artifact
 */
export type Form = {
    /**
     * Config of the artifact
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * OAuth of the artifact
     */
    oauth?: {
        [key: string]: unknown;
    };
    /**
     * Secrets of the artifact
     */
    secrets?: {
        [key: string]: unknown;
    };
};

/**
 * Function
 */
export type _Function = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: FunctionSpec;
    /**
     * Function status
     */
    status?: string;
};

/**
 * Function kit
 */
export type FunctionKit = {
    /**
     * Description of the function kit, very important for the agent to work with your kit
     */
    description?: string;
    /**
     * The kit name, very important for the agent to work with your kit
     */
    name?: string;
    schema?: FunctionSchema;
};

/**
 * Function schema
 */
export type FunctionSchema = {
    /**
     * List of schemas that this schema extends
     */
    allOf?: Array<unknown>;
    /**
     * List of possible schemas, any of which this schema could be
     */
    anyOf?: Array<unknown>;
    /**
     * Description of the schema
     */
    description?: string;
    /**
     * Enum values
     */
    enum?: Array<string>;
    /**
     * Format of the schema
     */
    format?: string;
    items?: FunctionSchema;
    /**
     * Maximum length for string types
     */
    maxLength?: number;
    /**
     * Maximum value for number types
     */
    maximum?: number;
    /**
     * Minimum length for string types
     */
    minLength?: number;
    /**
     * Minimum value for number types
     */
    minimum?: number;
    /**
     * Schema that this schema must not be
     */
    not?: {
        [key: string]: unknown;
    };
    /**
     * List of schemas, one of which this schema must be
     */
    oneOf?: Array<unknown>;
    /**
     * Pattern for string types
     */
    pattern?: string;
    /**
     * Properties of the schema
     */
    properties?: {
        [key: string]: FunctionSchema;
    };
    /**
     * Required properties of the schema
     */
    required?: Array<string>;
    /**
     * Title of the schema
     */
    title?: string;
    /**
     * Type of the schema
     */
    type?: string;
};

/**
 * Helper type for AdditionalProperties which can be either a boolean or a schema
 */
export type FunctionSchemaOrBool = {
    [key: string]: unknown;
};

/**
 * Function specification
 */
export type FunctionSpec = CoreSpec & {
    /**
     * Function description, very important for the agent function to work with an LLM
     */
    description?: string;
    schema?: FunctionSchema;
    triggers?: Triggers;
};

/**
 * Histogram bucket
 */
export type HistogramBucket = {
    /**
     * Count
     */
    count?: number;
    /**
     * End
     */
    end?: number;
    /**
     * Start
     */
    start?: number;
};

/**
 * Histogram stats
 */
export type HistogramStats = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
};

/**
 * Integration
 */
export type Integration = {
    /**
     * Integration additional infos
     */
    additionalInfos?: {
        [key: string]: string;
    };
    endpoints?: IntegrationEndpoints;
    headers?: IntegrationHeaders;
    /**
     * Integration name
     */
    name?: string;
    /**
     * Integration organizations
     */
    organizations?: Array<IntegrationOrganization>;
    params?: IntegrationQueryParams;
    /**
     * Integration repositories
     */
    repositories?: Array<IntegrationRepository>;
};

/**
 * Integration Connection
 */
export type IntegrationConnection = {
    metadata?: Metadata;
    spec?: IntegrationConnectionSpec;
};

/**
 * Integration connection specification
 */
export type IntegrationConnectionSpec = {
    /**
     * Additional configuration for the integration
     */
    config?: {
        [key: string]: string;
    };
    /**
     * Integration type
     */
    integration?: string;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Integration secret
     */
    secret?: {
        [key: string]: string;
    };
};

export type IntegrationConnectionsList = Array<string>;

/**
 * Integration endpoint
 */
export type IntegrationEndpoint = {
    /**
     * Integration endpoint body
     */
    body?: string;
    /**
     * Integration endpoint ignore models
     */
    ignoreModels?: Array<unknown>;
    /**
     * Integration endpoint method
     */
    method?: string;
    /**
     * Integration endpoint models
     */
    models?: Array<unknown>;
    /**
     * Integration endpoint stream key
     */
    streamKey?: string;
    streamToken?: IntegrationEndpointToken;
    token?: IntegrationEndpointToken;
};

/**
 * Integration endpoint token
 */
export type IntegrationEndpointToken = {
    /**
     * Integration endpoint token received
     */
    received?: string;
    /**
     * Integration endpoint token sent
     */
    sent?: string;
    /**
     * Integration endpoint token total
     */
    total?: string;
};

/**
 * Integration endpoints
 */
export type IntegrationEndpoints = {
    [key: string]: IntegrationEndpoint;
};

/**
 * Integration headers
 */
export type IntegrationHeaders = {
    [key: string]: string;
};

/**
 * Model obtained from an external authentication provider, such as HuggingFace, OpenAI, etc...
 */
export type IntegrationModel = {
    /**
     * Provider model author
     */
    author?: string;
    /**
     * Provider model created at
     */
    created_at?: string;
    /**
     * Provider model downloads
     */
    downloads?: number;
    /**
     * Model endpoint URL
     */
    endpoint?: string;
    /**
     * Provider model ID
     */
    id?: string;
    /**
     * Provider model library name
     */
    library_name?: string;
    /**
     * Provider model likes
     */
    likes?: number;
    /**
     * Is the model private
     */
    model_private?: string;
    /**
     * Provider model name
     */
    name?: string;
    /**
     * Provider model pipeline tag
     */
    pipeline_tag?: string;
    /**
     * Provider model tags
     */
    tags?: Array<string>;
    /**
     * Provider model trending score
     */
    trending_score?: number;
};

/**
 * Integration organization
 */
export type IntegrationOrganization = {
    /**
     * Provider organization avatar URL
     */
    avatar_url?: string;
    /**
     * Provider organization display name
     */
    displayName?: string;
    /**
     * Provider organization ID
     */
    id?: string;
    /**
     * Provider organization name
     */
    name?: string;
};

/**
 * Integration query params
 */
export type IntegrationQueryParams = {
    [key: string]: string;
};

/**
 * Integration repository
 */
export type IntegrationRepository = {
    /**
     * Repository ID
     */
    id?: string;
    /**
     * Whether the repository has Blaxel imports
     */
    isBl?: boolean;
    /**
     * Repository name
     */
    name?: string;
    /**
     * Repository owner
     */
    organization?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Job
 */
export type Job = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: JobSpec;
    /**
     * Job status
     */
    status?: string;
};

/**
 * Configuration for a job execution
 */
export type JobExecutionConfig = {
    /**
     * The maximum number of concurrent tasks for an execution
     */
    maxConcurrentTasks?: number;
    /**
     * The maximum number of retries for the job execution
     */
    maxRetries?: number;
    /**
     * The timeout for the job execution in seconds
     */
    timeout?: number;
};

/**
 * Metrics for job
 */
export type JobMetrics = {
    /**
     * Billable time
     */
    billableTime?: Array<unknown>;
    /**
     * CPU usage
     */
    cpuUsage?: Array<unknown>;
    /**
     * Executions chart
     */
    executionsChart?: {
        [key: string]: unknown;
    };
    /**
     * Executions running
     */
    executionsRunning?: Array<unknown>;
    /**
     * Total executions
     */
    executionsTotal?: {
        [key: string]: unknown;
    };
    /**
     * RAM usage
     */
    ramUsage?: Array<unknown>;
    /**
     * Tasks chart
     */
    tasksChart?: {
        [key: string]: unknown;
    };
    /**
     * Tasks running
     */
    tasksRunning?: Array<unknown>;
    /**
     * Total tasks
     */
    tasksTotal?: {
        [key: string]: unknown;
    };
};

/**
 * Job specification
 */
export type JobSpec = CoreSpec & {
    triggers?: Triggers;
};

/**
 * Jobs CPU usage
 */
export type JobsChartValue = {
    /**
     * Metric timestamp
     */
    timestamp?: string;
    /**
     * Metric value
     */
    value?: number;
};

/**
 * Jobs chart
 */
export type JobsNetworkChart = {
    received?: JobsChartValue;
    sent?: JobsChartValue;
};

/**
 * Jobs chart
 */
export type JobsSuccessFailedChart = {
    failed?: JobsChartValue;
    retried?: JobsChartValue;
    success?: JobsChartValue;
    /**
     * Metric timestamp
     */
    timestamp?: string;
    total?: JobsChartValue;
};

/**
 * Jobs executions
 */
export type JobsTotal = {
    /**
     * Failed executions
     */
    failed?: number;
    /**
     * Retried executions
     */
    retried?: number;
    /**
     * Running executions
     */
    running?: number;
    /**
     * Success executions
     */
    success?: number;
    /**
     * Total executions
     */
    total?: number;
};

/**
 * Last N requests
 */
export type LastNRequestsMetric = {
    /**
     * Timestamp
     */
    date?: string;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Latency metrics
 */
export type LatencyMetric = {
    globalHistogram?: HistogramBucket;
    globalStats?: HistogramStats;
    histogramPerCode?: HistogramBucket;
    statsPerCode?: HistogramStats;
};

/**
 * Location availability for policies
 */
export type LocationResponse = {
    /**
     * Continent of the location
     */
    continent?: string;
    /**
     * Country of the location
     */
    country?: string;
    /**
     * Hardware flavors available in the location
     */
    flavors?: Array<Flavor>;
    /**
     * Name of the location
     */
    location?: string;
    /**
     * Status of the location
     */
    status?: string;
};

/**
 * Response for logs
 */
export type LogsResponse = {
    /**
     * Data
     */
    data?: Array<unknown>;
};

/**
 * Response data for logs
 */
export type LogsResponseData = {
    /**
     * Body of the log
     */
    body?: string;
    /**
     * Log attributes
     */
    logAttributes?: Array<unknown>;
    /**
     * Severity number of the log
     */
    severityNumber?: number;
    /**
     * Timestamp of the log
     */
    timestamp?: string;
    /**
     * Trace ID of the log
     */
    traceId?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinition = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<unknown>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    /**
     * Entrypoint of the artifact
     */
    entrypoint?: {
        [key: string]: unknown;
    };
    /**
     * Form of the artifact
     */
    form?: {
        [key: string]: unknown;
    };
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Memory allocation by service name
 */
export type MemoryAllocationByName = {
    /**
     * Memory allocation value
     */
    allocation?: number;
    /**
     * Name
     */
    name?: string;
};

/**
 * Metrics for memory allocation
 */
export type MemoryAllocationMetric = {
    /**
     * Total memory allocation in GB-seconds
     */
    totalAllocation?: number;
};

/**
 * Metadata
 */
export type Metadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Model name
     */
    name?: string;
    /**
     * Plan
     */
    plan?: unknown;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Labels
 */
export type MetadataLabels = {
    [key: string]: string;
};

/**
 * Metric
 */
export type Metric = {
    /**
     * Metric value
     */
    rate?: number;
    /**
     * Metric value
     */
    requestTotal?: number;
    /**
     * Metric timestamp
     */
    timestamp?: string;
};

/**
 * Metrics for resources
 */
export type Metrics = {
    /**
     * Metrics for agents
     */
    agents?: unknown;
    /**
     * Metrics for functions
     */
    functions?: unknown;
    /**
     * Historical requests for all resources globally
     */
    inferenceGlobal?: Array<unknown>;
    /**
     * Historical requests for all resources globally
     */
    items?: Array<unknown>;
    /**
     * Metric value
     */
    lastNRequests?: number;
    /**
     * Metrics for models
     */
    models?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for all resources globally
     */
    requestTotal?: number;
    /**
     * Number of requests for all resources globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for all resources globally
     */
    rps?: number;
    /**
     * Number of requests per second for all resources globally per code
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Metrics for sandboxes
     */
    sandboxes?: unknown;
};

/**
 * Logical object representing a model
 */
export type Model = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: ModelSpec;
    /**
     * Model status
     */
    status?: string;
};

/**
 * Private cluster where the model deployment is deployed
 */
export type ModelPrivateCluster = {
    /**
     * The base url of the model in the private cluster
     */
    baseUrl?: string;
    /**
     * If true, the private cluster is available
     */
    enabled?: boolean;
    /**
     * The name of the private cluster
     */
    name?: string;
};

/**
 * Model specification
 */
export type ModelSpec = CoreSpec & unknown;

/**
 * OAuth of the artifact
 */
export type OAuth = {
    /**
     * Scope of the OAuth
     */
    scope?: Array<unknown>;
    /**
     * Type of the OAuth
     */
    type?: string;
};

/**
 * Owner fields for Persistance
 */
export type OwnerFields = {
    /**
     * The user or service account who created the resource
     */
    createdBy?: string;
    /**
     * The user or service account who updated the resource
     */
    updatedBy?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitation = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAccept = {
    /**
     * User email
     */
    email?: string;
    workspace?: Workspace;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationRender = {
    /**
     * User email
     */
    email?: string;
    /**
     * Invitation date
     */
    invitedAt?: string;
    invitedBy?: PendingInvitationRenderInvitedBy;
    /**
     * ACL role
     */
    role?: string;
    workspace?: PendingInvitationRenderWorkspace;
    workspaceDetails?: PendingInvitationWorkspaceDetails;
};

/**
 * Invited by
 */
export type PendingInvitationRenderInvitedBy = {
    /**
     * User email
     */
    email?: string;
    /**
     * User family name
     */
    family_name?: string;
    /**
     * User given name
     */
    given_name?: string;
    /**
     * User sub
     */
    sub?: string;
};

/**
 * Workspace
 */
export type PendingInvitationRenderWorkspace = {
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Workspace name
     */
    name?: string;
};

/**
 * Workspace details
 */
export type PendingInvitationWorkspaceDetails = {
    /**
     * List of user emails in the workspace
     */
    emails?: Array<unknown>;
    /**
     * Number of users in the workspace
     */
    user_number?: number;
};

/**
 * Pod template specification
 */
export type PodTemplateSpec = {
    [key: string]: unknown;
};

export type PoliciesList = Array<string>;

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type Policy = {
    metadata?: Metadata;
    spec?: PolicySpec;
};

/**
 * Policy location
 */
export type PolicyLocation = {
    /**
     * Policy location name
     */
    name?: string;
    /**
     * Policy location type
     */
    type?: string;
};

/**
 * PolicyLocations is a local type that wraps a slice of Location
 */
export type PolicyLocations = Array<PolicyLocation>;

/**
 * PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
 */
export type PolicyMaxTokens = {
    /**
     * Granularity
     */
    granularity?: string;
    /**
     * Input
     */
    input?: number;
    /**
     * Output
     */
    output?: number;
    /**
     * RatioInputOverOutput
     */
    ratioInputOverOutput?: number;
    /**
     * Step
     */
    step?: number;
    /**
     * Total
     */
    total?: number;
};

/**
 * PolicyResourceType is a type of resource, e.g. model, function, etc.
 */
export type PolicyResourceType = string;

/**
 * PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
 */
export type PolicyResourceTypes = Array<PolicyResourceType>;

/**
 * Policy specification
 */
export type PolicySpec = {
    flavors?: Flavors;
    locations?: PolicyLocations;
    maxTokens?: PolicyMaxTokens;
    resourceTypes?: PolicyResourceTypes;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Policy type, can be location or flavor
     */
    type?: string;
};

/**
 * A port for a resource
 */
export type Port = {
    /**
     * The name of the port
     */
    name?: string;
    /**
     * The protocol of the port
     */
    protocol?: string;
    /**
     * The target port of the port
     */
    target?: number;
};

/**
 * Set of ports for a resource
 */
export type Ports = Array<Port>;

/**
 * Preview of a Resource
 */
export type Preview = {
    metadata?: PreviewMetadata;
    spec?: PreviewSpec;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Preview of a Resource
 */
export type PreviewSpec = {
    /**
     * Custom domain bound to this preview
     */
    customDomain?: string;
    /**
     * The expiration date for the preview in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * Port of the preview
     */
    port?: number;
    /**
     * Prefix URL
     */
    prefixUrl?: string;
    /**
     * Whether the preview is public
     */
    public?: boolean;
    /**
     * Region where the preview is deployed, this is readonly
     */
    region?: string;
    /**
     * Those headers will be set in all requests to your preview. This is especially useful to set the Authorization header.
     */
    requestHeaders?: {
        [key: string]: string;
    };
    /**
     * Those headers will be set in all responses of your preview. This is especially useful to set the CORS headers.
     */
    responseHeaders?: {
        [key: string]: string;
    };
    /**
     * Time to live for the preview (e.g., "1h", "24h", "7d"). After this duration, the preview will be automatically deleted.
     */
    ttl?: string;
    /**
     * URL of the preview
     */
    url?: string;
};

/**
 * Token for a Preview
 */
export type PreviewToken = {
    metadata?: PreviewTokenMetadata;
    spec?: PreviewTokenSpec;
};

/**
 * PreviewTokenMetadata
 */
export type PreviewTokenMetadata = {
    /**
     * Token name
     */
    name?: string;
    /**
     * Preview name
     */
    previewName?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Spec for a Preview Token
 */
export type PreviewTokenSpec = {
    /**
     * Whether the token is expired
     */
    expired?: boolean;
    /**
     * Expiration time of the token
     */
    expiresAt?: string;
    /**
     * Token
     */
    token?: string;
};

/**
 * A private cluster where models can be located on.
 */
export type PrivateCluster = TimeFields & OwnerFields & {
    /**
     * The private cluster's continent, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    continent?: string;
    /**
     * The country where the private cluster is located, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    country?: string;
    /**
     * The private cluster's display Name
     */
    displayName?: string;
    /**
     * Whether the private cluster is healthy or not, used to determine if the private cluster is ready to run inference
     */
    healthy?: boolean;
    /**
     * The private cluster's unique name
     */
    lastHealthCheckTime?: string;
    /**
     * The private cluster's latitude, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    latitude?: string;
    /**
     * The private cluster's longitude, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    longitude?: string;
    /**
     * The name of the private cluster, it must be unique
     */
    name?: string;
    /**
     * The service account (operator) that owns the cluster
     */
    ownedBy?: string;
    /**
     * The workspace the private cluster belongs to
     */
    workspace?: string;
};

/**
 * Private location available for policies
 */
export type PrivateLocation = {
    /**
     * Location name
     */
    name?: string;
};

export type PublicIp = {
    /**
     * Description of the region/location
     */
    description?: string;
    /**
     * List of public ipv4 addresses
     */
    ipv4Cidrs?: Array<string>;
    /**
     * List of public ipv6 addresses
     */
    ipv6Cidrs?: Array<string>;
};

export type PublicIps = {
    [key: string]: PublicIp;
};

/**
 * Repository
 */
export type Repository = {
    /**
     * Repository type
     */
    type?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Request duration over time metric
 */
export type RequestDurationOverTimeMetric = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
    /**
     * Timestamp
     */
    timestamp?: string;
};

/**
 * Request duration over time metrics
 */
export type RequestDurationOverTimeMetrics = {
    requestDurationOverTime?: RequestDurationOverTimeMetric;
};

/**
 * Request total by origin metric
 */
export type RequestTotalByOriginMetric = {
    /**
     * Request total by origin
     */
    requestTotalByOrigin?: {
        [key: string]: unknown;
    };
    /**
     * Request total by origin and code
     */
    requestTotalByOriginAndCode?: {
        [key: string]: unknown;
    };
};

/**
 * Metrics for request total
 */
export type RequestTotalMetric = {
    /**
     * Historical requests for all resources globally
     */
    items?: Array<unknown>;
    /**
     * Number of requests for all resources globally
     */
    requestTotal?: number;
    /**
     * Number of requests for all resources globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for all resources globally
     */
    rps?: number;
    /**
     * Number of requests for all resources globally
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
};

/**
 * Request total response data
 */
export type RequestTotalResponseData = {
    /**
     * Request total
     */
    requestTotal?: number;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Resource
 */
export type Resource = {
    /**
     * Name of the resource
     */
    name?: string;
    /**
     * Type of the resource
     */
    type?: string;
    /**
     * Workspace of the resource
     */
    workspace?: string;
};

/**
 * Log for a resource deployment (eg. model deployment, function deployment)
 */
export type ResourceLog = {
    /**
     * Content of the log
     */
    message?: string;
    /**
     * Severity of the log
     */
    severity?: number;
    /**
     * The timestamp of the log
     */
    timestamp?: string;
    /**
     * Trace ID of the log
     */
    trace_id?: string;
};

/**
 * Chart for a resource log
 */
export type ResourceLogChart = {
    /**
     * Count of the log
     */
    count?: number;
    /**
     * Debug count of the log
     */
    debug?: number;
    /**
     * Error count of the log
     */
    error?: number;
    /**
     * Fatal count of the log
     */
    fatal?: number;
    /**
     * Info count of the log
     */
    info?: number;
    /**
     * Timestamp of the log
     */
    timestamp?: string;
    /**
     * Trace count of the log
     */
    trace?: number;
    /**
     * Unknown count of the log
     */
    unknown?: number;
    /**
     * Warning count of the log
     */
    warning?: number;
};

/**
 * Response for a resource log
 */
export type ResourceLogResponse = {
    /**
     * Chart
     */
    chart?: Array<unknown>;
    /**
     * Logs
     */
    logs?: Array<unknown>;
    /**
     * Total count of logs
     */
    totalCount?: number;
};

/**
 * Metrics for a single resource deployment (eg. model deployment, function deployment)
 */
export type ResourceMetrics = {
    billableTime?: BillableTimeMetric;
    inferenceErrorsGlobal?: ArrayMetric;
    inferenceGlobal?: ArrayMetric;
    lastNRequests?: ArrayMetric;
    latency?: LatencyMetric;
    latencyPrevious?: LatencyMetric;
    memoryAllocation?: MemoryAllocationMetric;
    modelTtft?: LatencyMetric;
    modelTtftOverTime?: TimeToFirstTokenOverTimeMetrics;
    requestDurationOverTime?: RequestDurationOverTimeMetrics;
    /**
     * Number of requests for the resource globally
     */
    requestTotal?: number;
    requestTotalByOrigin?: RequestTotalByOriginMetric;
    requestTotalByOriginPrevious?: RequestTotalByOriginMetric;
    /**
     * Number of requests for the resource globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for the resource globally per code for the previous period
     */
    requestTotalPerCodePrevious?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for the resource globally for the previous period
     */
    requestTotalPrevious?: number;
    /**
     * Number of requests per second for the resource globally
     */
    rps?: number;
    /**
     * Number of requests per second for the resource globally per code
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for the resource globally per code for the previous period
     */
    rpsPerCodePrevious?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for the resource globally for the previous period
     */
    rpsPrevious?: number;
    tokenRate?: TokenRateMetrics;
    tokenTotal?: TokenTotalMetric;
};

/**
 * Log for a resource deployment (eg. model deployment, function deployment)
 */
export type ResourceTrace = {
    /**
     * Duration in nanoseconds
     */
    duration?: number;
    /**
     * Has error
     */
    hasError?: boolean;
    /**
     * The timestamp of the log
     */
    startTime?: string;
    /**
     * Status code
     */
    statusCode?: number;
    /**
     * Trace ID of the log
     */
    traceID?: string;
};

/**
 * Revision configuration
 */
export type RevisionConfiguration = {
    /**
     * Active revision id
     */
    active?: string;
    /**
     * Canary revision id
     */
    canary?: string;
    /**
     * Canary revision percent
     */
    canaryPercent?: number;
    /**
     * Traffic percentage
     */
    traffic?: number;
};

/**
 * Revision metadata
 */
export type RevisionMetadata = {
    /**
     * Is the revision active
     */
    active?: boolean;
    /**
     * Is the revision canary
     */
    canary?: boolean;
    /**
     * Revision created at
     */
    createdAt?: string;
    /**
     * Revision created by
     */
    createdBy?: string;
    /**
     * Revision ID
     */
    id?: string;
    /**
     * Is the revision previous active
     */
    previousActive?: boolean;
    /**
     * Status of the revision
     */
    status?: string;
    /**
     * Percent of traffic to the revision
     */
    trafficPercent?: number;
};

/**
 * Set of configurations for a deployment
 */
export type Runtime = {
    /**
     * The arguments to pass to the deployment runtime
     */
    args?: Array<unknown>;
    /**
     * The command to run the deployment
     */
    command?: Array<unknown>;
    /**
     * The configuration for the deployment
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * The CPU for the deployment in cores, only available for private cluster
     */
    cpu?: number;
    /**
     * Endpoint Name of the model. In case of hf_private_endpoint, it is the endpoint name. In case of hf_public_endpoint, it is not used.
     */
    endpointName?: string;
    /**
     * The env variables to set in the deployment. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<unknown>;
    /**
     * The expiration date for the deployment in ISO 8601 format - 2024-12-31T23:59:59Z
     */
    expires?: string;
    /**
     * The generation of the deployment
     */
    generation?: string;
    /**
     * The Docker image for the deployment
     */
    image?: string;
    /**
     * The maximum number of concurrent task for an execution
     */
    maxConcurrentTasks?: number;
    /**
     * The maximum number of retries for the deployment
     */
    maxRetries?: number;
    /**
     * The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
     */
    maxScale?: number;
    /**
     * The memory for the deployment in MB
     */
    memory?: number;
    /**
     * The port to serve the metrics on
     */
    metricPort?: number;
    /**
     * The maximum number of replicas for the deployment.
     */
    minScale?: number;
    /**
     * The slug name of the origin model at HuggingFace.
     */
    model?: string;
    /**
     * The organization of the model
     */
    organization?: string;
    ports?: Ports;
    /**
     * The readiness probe. Should be a Kubernetes Probe type
     */
    startupProbe?: {
        [key: string]: unknown;
    };
    /**
     * The timeout for the deployment in seconds
     */
    timeout?: number;
    /**
     * The TTL for the deployment in seconds - 30m, 24h, 7d
     */
    ttl?: string;
    /**
     * The type of origin for the deployment (hf_private_endpoint, hf_public_endpoint)
     */
    type?: string;
};

/**
 * Micro VM for running agentic tasks
 */
export type Sandbox = {
    events?: CoreEvents;
    /**
     * Last time the sandbox was used (read-only, managed by the system)
     */
    lastUsedAt?: string;
    metadata?: Metadata;
    spec?: SandboxSpec;
    /**
     * Sandbox status
     */
    status?: string;
    /**
     * TTL timestamp for automatic deletion (optional, nil means no auto-deletion)
     */
    ttl?: number;
};

/**
 * Sandbox definition for admin store operations
 */
export type SandboxDefinition = {
    /**
     * Categories of the defintion
     */
    categories?: Array<unknown>;
    /**
     * If the definition is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the defintion
     */
    description?: string;
    /**
     * Display name of the definition
     */
    displayName?: string;
    /**
     * If the definition is enterprise
     */
    enterprise?: boolean;
    /**
     * Icon of the definition
     */
    icon?: string;
    /**
     * Image of the Sandbox definition
     */
    image?: string;
    /**
     * Long description of the defintion
     */
    longDescription?: string;
    /**
     * Memory of the Sandbox definition in MB
     */
    memory?: number;
    /**
     * Name of the artifact
     */
    name?: string;
    ports?: Ports;
    /**
     * URL of the definition
     */
    url?: string;
};

/**
 * Sandbox specification
 */
export type SandboxSpec = CoreSpec & {
    /**
     * Region where the sandbox should be created (e.g. us-pdx-1, eu-lon-1)
     */
    region?: string;
    volumes?: VolumeAttachments;
};

/**
 * Name of a Sandbox definition
 */
export type SandboxStoreDefinitionName = unknown;

/**
 * Configuration for a serverless deployment
 */
export type ServerlessConfig = {
    /**
     * The configuration for the deployment
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * The maximum number of retries for the deployment
     */
    maxRetries?: number;
    /**
     * The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
     */
    maxScale?: number;
    /**
     * The maximum number of replicas for the deployment.
     */
    minScale?: number;
    /**
     * The timeout for the deployment in seconds
     */
    timeout?: number;
};

/**
 * Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
 */
export type SpecConfiguration = {
    /**
     * ACconfiguration secret
     */
    secret?: boolean;
    /**
     * Configuration value
     */
    value?: string;
};

/**
 * Response when starting a Sandbox
 */
export type StartSandbox = {
    /**
     * Human readable message about the start operation
     */
    message?: string;
    metadata?: Metadata;
    /**
     * Status of the Sandbox start operation
     */
    status?: string;
};

/**
 * Response when stopping a Sandbox
 */
export type StopSandbox = {
    /**
     * Human readable message about the stop operation
     */
    message?: string;
    metadata?: Metadata;
    /**
     * Status of the Sandbox stop operation
     */
    status?: string;
};

/**
 * Store agent
 */
export type StoreAgent = TimeFields & OwnerFields & {
    /**
     * Store agent configuration
     */
    configuration?: Array<StoreConfiguration>;
    /**
     * Store agent description
     */
    description?: string;
    /**
     * Store agent display name
     */
    displayName?: string;
    /**
     * Store agent image
     */
    image?: string;
    /**
     * Store agent labels
     */
    labels?: {
        [key: string]: unknown;
    };
    /**
     * Store agent name
     */
    name?: string;
    /**
     * Store agent prompt, this is to define what the agent does
     */
    prompt?: string;
};

/**
 * Store configuration for resources (eg: agent, function, etc)
 */
export type StoreConfiguration = {
    /**
     * Available models for the configuration
     */
    availableModels?: Array<string>;
    /**
     * Store configuration description
     */
    description?: string;
    /**
     * Store configuration display name
     */
    displayName?: string;
    /**
     * Conditional rendering for the configuration, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration name
     */
    name?: string;
    options?: Array<StoreConfigurationOption>;
    /**
     * Store configuration required
     */
    required?: boolean;
    /**
     * Store configuration secret
     */
    secret?: boolean;
    /**
     * Store configuration type
     */
    type?: string;
};

/**
 * Store configuration options for a select type configuration
 */
export type StoreConfigurationOption = {
    /**
     * Conditional rendering for the configuration option, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration option label
     */
    label?: string;
    /**
     * Store configuration option value
     */
    value?: string;
};

/**
 * Blaxel template
 */
export type Template = {
    /**
     * Default branch of the template
     */
    defaultBranch?: string;
    /**
     * Description of the template
     */
    description?: string;
    /**
     * Number of downloads/clones of the repository
     */
    downloadCount?: number;
    /**
     * Number of forks the repository has
     */
    forksCount?: number;
    /**
     * URL to the template's icon
     */
    icon?: string;
    /**
     * URL to the template's icon in dark mode
     */
    iconDark?: string;
    /**
     * Name of the template
     */
    name?: string;
    /**
     * SHA of the variable
     */
    sha?: string;
    /**
     * Number of stars the repository has
     */
    starCount?: number;
    /**
     * Topic of the template
     */
    topics?: Array<string>;
    /**
     * URL of the template
     */
    url?: string;
    /**
     * Variables of the template
     */
    variables?: Array<TemplateVariable>;
};

/**
 * Blaxel template variable
 */
export type TemplateVariable = {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Integration of the variable
     */
    integration?: string;
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Path of the variable
     */
    path?: string;
    /**
     * Whether the variable is secret
     */
    secret?: boolean;
};

/**
 * Time fields for Persistance
 */
export type TimeFields = {
    /**
     * The date and time when the resource was created
     */
    createdAt?: string;
    /**
     * The date and time when the resource was updated
     */
    updatedAt?: string;
};

/**
 * Time to first token over time metrics
 */
export type TimeToFirstTokenOverTimeMetrics = {
    timeToFirstTokenOverTime?: RequestDurationOverTimeMetric;
};

/**
 * Token rate metric
 */
export type TokenRateMetric = {
    /**
     * Model ID
     */
    model?: string;
    /**
     * Provider name
     */
    provider?: string;
    /**
     * Provider integration name
     */
    providerName?: string;
    /**
     * Timestamp
     */
    timestamp?: string;
    /**
     * Total tokens
     */
    tokenTotal?: number;
    /**
     * Trend
     */
    trend?: number;
};

/**
 * Token rate metrics
 */
export type TokenRateMetrics = {
    tokenRate?: TokenRateMetric;
    tokenRateInput?: TokenRateMetric;
    tokenRateOutput?: TokenRateMetric;
};

/**
 * Token total metric
 */
export type TokenTotalMetric = {
    /**
     * Average input token per request
     */
    averageTokenInputPerRequest?: number;
    /**
     * Average output token per request
     */
    averageTokenOutputPerRequest?: number;
    /**
     * Average token per request
     */
    averageTokenPerRequest?: number;
    /**
     * Total input tokens
     */
    tokenInput?: number;
    /**
     * Total output tokens
     */
    tokenOutput?: number;
    /**
     * Total tokens
     */
    tokenTotal?: number;
};

/**
 * Trace IDs response
 */
export type TraceIdsResponse = {
    [key: string]: unknown;
};

/**
 * Trigger configuration
 */
export type Trigger = {
    configuration?: TriggerConfiguration;
    /**
     * The id of the trigger
     */
    id?: string;
    /**
     * The type of trigger, can be http or http-async
     */
    type?: string;
};

/**
 * Trigger configuration
 */
export type TriggerConfiguration = {
    /**
     * The authentication type of the trigger
     */
    authenticationType?: string;
    /**
     * The path of the trigger
     */
    path?: string;
    /**
     * The retry of the trigger
     */
    retry?: number;
    /**
     * The schedule of the trigger, cron expression * * * * *
     */
    schedule?: string;
    /**
     * The tasks configuration of the cronjob
     */
    tasks?: Array<TriggerConfigurationTask>;
};

/**
 * The tasks configuration of the cronjob
 */
export type TriggerConfigurationTask = {
    [key: string]: unknown;
};

/**
 * Triggers to use your agent
 */
export type Triggers = Array<Trigger>;

/**
 * Volume resource for persistent storage
 */
export type Volume = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: VolumeSpec;
    state?: VolumeState;
    /**
     * Volume status computed from events
     */
    status?: string;
    /**
     * Timestamp when the volume was marked for termination
     */
    terminatedAt?: string;
};

/**
 * Volume attachment configuration for sandbox
 */
export type VolumeAttachment = {
    /**
     * Mount path in the container
     */
    mountPath?: string;
    /**
     * Name of the volume to attach
     */
    name?: string;
    /**
     * Whether the volume is mounted as read-only
     */
    readOnly?: boolean;
};

export type VolumeAttachments = Array<VolumeAttachment>;

/**
 * Volume specification - immutable configuration
 */
export type VolumeSpec = {
    /**
     * Region where the volume should be created (e.g. us-pdx-1, eu-lon-1)
     */
    region?: string;
    /**
     * Size of the volume in MB
     */
    size?: number;
};

/**
 * Volume state - mutable runtime state
 */
export type VolumeState = {
    /**
     * Resource this volume is attached to (e.g. "sandbox:my-sandbox", "model:my-model")
     */
    attachedTo?: string;
};

/**
 * WebSocket connection details
 */
export type WebsocketChannel = TimeFields & {
    /**
     * Unique connection ID
     */
    connection_id?: string;
    /**
     * Workspace the connection belongs to
     */
    workspace?: string;
};

/**
 * WebSocket connection details
 */
export type WebsocketMessage = TimeFields & {
    /**
     * Unique message ID
     */
    id?: string;
    /**
     * Message
     */
    message?: string;
    /**
     * TTL timestamp for automatic deletion
     */
    ttl?: number;
    /**
     * Workspace the connection belongs to
     */
    workspace?: string;
};

/**
 * Workspace
 */
export type Workspace = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Autogenerated unique workspace id
     */
    id?: string;
    /**
     * Workspace labels
     */
    labels?: {
        [key: string]: unknown;
    };
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
};

/**
 * Workspace runtime
 */
export type WorkspaceRuntime = {
    /**
     * Workspace generation
     */
    generation?: string;
};

/**
 * Workspace user
 */
export type WorkspaceUser = {
    /**
     * Whether the user has accepted the workspace invitation
     */
    accepted?: boolean;
    /**
     * Workspace user email
     */
    email?: string;
    /**
     * Whether the user's email has been verified
     */
    email_verified?: boolean;
    /**
     * Workspace user family name
     */
    family_name?: string;
    /**
     * Workspace user given name
     */
    given_name?: string;
    /**
     * Workspace user role
     */
    role?: string;
    /**
     * Workspace user identifier
     */
    sub?: string;
};

export type ListAgentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agents';
};

export type ListAgentsResponses = {
    /**
     * successful operation
     */
    200: Array<Agent>;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type CreateAgentData = {
    body: Agent;
    path?: never;
    query?: never;
    url: '/agents';
};

export type CreateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type DeleteAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type GetAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body: Agent;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type UpdateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type ListAgentRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}/revisions';
};

export type ListAgentRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListAgentRevisionsResponse = ListAgentRevisionsResponses[keyof ListAgentRevisionsResponses];

export type GetConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/configuration';
};

export type GetConfigurationResponses = {
    /**
     * Configuration of the control plane
     */
    200: Configuration;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type ListCustomDomainsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type ListCustomDomainsResponses = {
    /**
     * successful operation
     */
    200: Array<CustomDomain>;
};

export type ListCustomDomainsResponse = ListCustomDomainsResponses[keyof ListCustomDomainsResponses];

export type CreateCustomDomainData = {
    body: CustomDomain;
    path?: never;
    query?: never;
    url: '/customdomains';
};

export type CreateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type CreateCustomDomainResponse = CreateCustomDomainResponses[keyof CreateCustomDomainResponses];

export type DeleteCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type DeleteCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type DeleteCustomDomainResponse = DeleteCustomDomainResponses[keyof DeleteCustomDomainResponses];

export type GetCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type GetCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type GetCustomDomainResponse = GetCustomDomainResponses[keyof GetCustomDomainResponses];

export type UpdateCustomDomainData = {
    body: CustomDomain;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}';
};

export type UpdateCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type UpdateCustomDomainResponse = UpdateCustomDomainResponses[keyof UpdateCustomDomainResponses];

export type VerifyCustomDomainData = {
    body?: never;
    path: {
        /**
         * Name of the custom domain
         */
        domainName: string;
    };
    query?: never;
    url: '/customdomains/{domainName}/verify';
};

export type VerifyCustomDomainResponses = {
    /**
     * successful operation
     */
    200: CustomDomain;
};

export type VerifyCustomDomainResponse = VerifyCustomDomainResponses[keyof VerifyCustomDomainResponses];

export type ListFunctionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/functions';
};

export type ListFunctionsResponses = {
    /**
     * successful operation
     */
    200: Array<_Function>;
};

export type ListFunctionsResponse = ListFunctionsResponses[keyof ListFunctionsResponses];

export type CreateFunctionData = {
    body: _Function;
    path?: never;
    query?: never;
    url: '/functions';
};

export type CreateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type CreateFunctionResponse = CreateFunctionResponses[keyof CreateFunctionResponses];

export type DeleteFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type DeleteFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type DeleteFunctionResponse = DeleteFunctionResponses[keyof DeleteFunctionResponses];

export type GetFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type GetFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type GetFunctionResponse = GetFunctionResponses[keyof GetFunctionResponses];

export type UpdateFunctionData = {
    body: _Function;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type UpdateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type UpdateFunctionResponse = UpdateFunctionResponses[keyof UpdateFunctionResponses];

export type ListFunctionRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}/revisions';
};

export type ListFunctionRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListFunctionRevisionsResponse = ListFunctionRevisionsResponses[keyof ListFunctionRevisionsResponses];

export type GetIntegrationData = {
    body?: never;
    path: {
        /**
         * Name of the integration
         */
        integrationName: string;
    };
    query?: never;
    url: '/integrations/{integrationName}';
};

export type GetIntegrationResponses = {
    /**
     * successful operation
     */
    200: Integration;
};

export type GetIntegrationResponse = GetIntegrationResponses[keyof GetIntegrationResponses];

export type ListIntegrationConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type ListIntegrationConnectionsResponses = {
    /**
     * successful operation
     */
    200: Array<IntegrationConnection>;
};

export type ListIntegrationConnectionsResponse = ListIntegrationConnectionsResponses[keyof ListIntegrationConnectionsResponses];

export type CreateIntegrationConnectionData = {
    body: IntegrationConnection;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type CreateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type CreateIntegrationConnectionResponse = CreateIntegrationConnectionResponses[keyof CreateIntegrationConnectionResponses];

export type DeleteIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type DeleteIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type DeleteIntegrationConnectionResponse = DeleteIntegrationConnectionResponses[keyof DeleteIntegrationConnectionResponses];

export type GetIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type GetIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type GetIntegrationConnectionResponse = GetIntegrationConnectionResponses[keyof GetIntegrationConnectionResponses];

export type UpdateIntegrationConnectionData = {
    body: IntegrationConnection;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type UpdateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type UpdateIntegrationConnectionResponse = UpdateIntegrationConnectionResponses[keyof UpdateIntegrationConnectionResponses];

export type GetIntegrationConnectionModelEndpointConfigurationsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/endpointConfigurations';
};

export type GetIntegrationConnectionModelEndpointConfigurationsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListIntegrationConnectionModelsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models';
};

export type ListIntegrationConnectionModelsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetIntegrationConnectionModelData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
        /**
         * Model ID
         */
        modelId: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models/{modelId}';
};

export type GetIntegrationConnectionModelResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListJobsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type ListJobsResponses = {
    /**
     * successful operation
     */
    200: Array<Job>;
};

export type ListJobsResponse = ListJobsResponses[keyof ListJobsResponses];

export type CreateJobData = {
    body: Job;
    path?: never;
    query?: never;
    url: '/jobs';
};

export type CreateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type CreateJobResponse = CreateJobResponses[keyof CreateJobResponses];

export type DeleteJobData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type DeleteJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type DeleteJobResponse = DeleteJobResponses[keyof DeleteJobResponses];

export type GetJobData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type GetJobResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type GetJobResponse = GetJobResponses[keyof GetJobResponses];

export type UpdateJobData = {
    body: Job;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}';
};

export type UpdateJobResponses = {
    /**
     * successful operation
     */
    200: Job;
};

export type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];

export type ListJobRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the job
         */
        jobId: string;
    };
    query?: never;
    url: '/jobs/{jobId}/revisions';
};

export type ListJobRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListJobRevisionsResponse = ListJobRevisionsResponses[keyof ListJobRevisionsResponses];

export type ListLocationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/locations';
};

export type ListLocationsResponses = {
    /**
     * successful operation
     */
    200: Array<LocationResponse>;
};

export type ListLocationsResponse = ListLocationsResponses[keyof ListLocationsResponses];

export type ListMcpHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mcp/hub';
};

export type ListMcpHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<McpDefinition>;
};

export type ListMcpHubDefinitionsResponse = ListMcpHubDefinitionsResponses[keyof ListMcpHubDefinitionsResponses];

export type ListModelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/models';
};

export type ListModelsResponses = {
    /**
     * successful operation
     */
    200: Array<Model>;
};

export type ListModelsResponse = ListModelsResponses[keyof ListModelsResponses];

export type CreateModelData = {
    body: Model;
    path?: never;
    query?: never;
    url: '/models';
};

export type CreateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type CreateModelResponse = CreateModelResponses[keyof CreateModelResponses];

export type DeleteModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type DeleteModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type DeleteModelResponse = DeleteModelResponses[keyof DeleteModelResponses];

export type GetModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type GetModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type GetModelResponse = GetModelResponses[keyof GetModelResponses];

export type UpdateModelData = {
    body: Model;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type UpdateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type UpdateModelResponse = UpdateModelResponses[keyof UpdateModelResponses];

export type ListModelRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}/revisions';
};

export type ListModelRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListModelRevisionsResponse = ListModelRevisionsResponses[keyof ListModelRevisionsResponses];

export type ListPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/policies';
};

export type ListPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<Policy>;
};

export type ListPoliciesResponse = ListPoliciesResponses[keyof ListPoliciesResponses];

export type CreatePolicyData = {
    body: Policy;
    path?: never;
    query?: never;
    url: '/policies';
};

export type CreatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type CreatePolicyResponse = CreatePolicyResponses[keyof CreatePolicyResponses];

export type DeletePolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type DeletePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type DeletePolicyResponse = DeletePolicyResponses[keyof DeletePolicyResponses];

export type GetPolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type GetPolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type GetPolicyResponse = GetPolicyResponses[keyof GetPolicyResponses];

export type UpdatePolicyData = {
    body: Policy;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type UpdatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type UpdatePolicyResponse = UpdatePolicyResponses[keyof UpdatePolicyResponses];

export type ListPrivateClustersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/privateclusters';
};

export type ListPrivateClustersErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type ListPrivateClustersResponses = {
    /**
     * successful operation
     */
    200: Array<PrivateCluster>;
};

export type ListPrivateClustersResponse = ListPrivateClustersResponses[keyof ListPrivateClustersResponses];

export type CreatePrivateClusterData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/privateclusters';
};

export type CreatePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreatePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type CreatePrivateClusterResponse = CreatePrivateClusterResponses[keyof CreatePrivateClusterResponses];

export type DeletePrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type DeletePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeletePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type DeletePrivateClusterResponse = DeletePrivateClusterResponses[keyof DeletePrivateClusterResponses];

export type GetPrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type GetPrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * private cluster not found
     */
    404: unknown;
};

export type GetPrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type GetPrivateClusterResponse = GetPrivateClusterResponses[keyof GetPrivateClusterResponses];

export type UpdatePrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type UpdatePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdatePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type UpdatePrivateClusterResponse = UpdatePrivateClusterResponses[keyof UpdatePrivateClusterResponses];

export type GetPrivateClusterHealthData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}/health';
};

export type GetPrivateClusterHealthErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPrivateClusterHealthResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type UpdatePrivateClusterHealthData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}/health';
};

export type UpdatePrivateClusterHealthErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdatePrivateClusterHealthResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListAllPendingInvitationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/profile/invitations';
};

export type ListAllPendingInvitationsErrors = {
    /**
     * no pending invitations
     */
    404: unknown;
};

export type ListAllPendingInvitationsResponses = {
    /**
     * successful operation
     */
    200: Array<PendingInvitationRender>;
};

export type ListAllPendingInvitationsResponse = ListAllPendingInvitationsResponses[keyof ListAllPendingInvitationsResponses];

export type ListPublicIpsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/publicIps';
};

export type ListPublicIpsResponses = {
    /**
     * successful operation
     */
    200: PublicIps;
};

export type ListPublicIpsResponse = ListPublicIpsResponses[keyof ListPublicIpsResponses];

export type ListSandboxHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandbox/hub';
};

export type ListSandboxHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<SandboxDefinition>;
};

export type ListSandboxHubDefinitionsResponse = ListSandboxHubDefinitionsResponses[keyof ListSandboxHubDefinitionsResponses];

export type ListSandboxesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type ListSandboxesResponses = {
    /**
     * successful operation
     */
    200: Array<Sandbox>;
};

export type ListSandboxesResponse = ListSandboxesResponses[keyof ListSandboxesResponses];

export type CreateSandboxData = {
    body: Sandbox;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type CreateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type CreateSandboxResponse = CreateSandboxResponses[keyof CreateSandboxResponses];

export type DeleteSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type DeleteSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type DeleteSandboxResponse = DeleteSandboxResponses[keyof DeleteSandboxResponses];

export type GetSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type GetSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type GetSandboxResponse = GetSandboxResponses[keyof GetSandboxResponses];

export type UpdateSandboxData = {
    body: Sandbox;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type UpdateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type UpdateSandboxResponse = UpdateSandboxResponses[keyof UpdateSandboxResponses];

export type ListSandboxPreviewsData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type ListSandboxPreviewsResponses = {
    /**
     * successful operation
     */
    200: Array<Preview>;
};

export type ListSandboxPreviewsResponse = ListSandboxPreviewsResponses[keyof ListSandboxPreviewsResponses];

export type CreateSandboxPreviewData = {
    body: Preview;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type CreateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type CreateSandboxPreviewResponse = CreateSandboxPreviewResponses[keyof CreateSandboxPreviewResponses];

export type DeleteSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type DeleteSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type DeleteSandboxPreviewResponse = DeleteSandboxPreviewResponses[keyof DeleteSandboxPreviewResponses];

export type GetSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type GetSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type GetSandboxPreviewResponse = GetSandboxPreviewResponses[keyof GetSandboxPreviewResponses];

export type UpdateSandboxPreviewData = {
    body: Preview;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type UpdateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type UpdateSandboxPreviewResponse = UpdateSandboxPreviewResponses[keyof UpdateSandboxPreviewResponses];

export type ListSandboxPreviewTokensData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type ListSandboxPreviewTokensResponses = {
    /**
     * successful operation
     */
    200: Array<PreviewToken>;
};

export type ListSandboxPreviewTokensResponse = ListSandboxPreviewTokensResponses[keyof ListSandboxPreviewTokensResponses];

export type CreateSandboxPreviewTokenData = {
    body: PreviewToken;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type CreateSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: PreviewToken;
};

export type CreateSandboxPreviewTokenResponse = CreateSandboxPreviewTokenResponses[keyof CreateSandboxPreviewTokenResponses];

export type DeleteSandboxPreviewTokenData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
        /**
         * Name of the Token
         */
        tokenName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens/{tokenName}';
};

export type DeleteSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type DeleteSandboxPreviewTokenResponse = DeleteSandboxPreviewTokenResponses[keyof DeleteSandboxPreviewTokenResponses];

export type StartSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/start';
};

export type StartSandboxErrors = {
    /**
     * Sandbox is already running
     */
    409: unknown;
};

export type StartSandboxResponses = {
    /**
     * successful operation
     */
    200: StartSandbox;
};

export type StartSandboxResponse = StartSandboxResponses[keyof StartSandboxResponses];

export type StopSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/stop';
};

export type StopSandboxErrors = {
    /**
     * Sandbox is not running
     */
    409: unknown;
};

export type StopSandboxResponses = {
    /**
     * successful operation
     */
    200: StopSandbox;
};

export type StopSandboxResponse = StopSandboxResponses[keyof StopSandboxResponses];

export type GetWorkspaceServiceAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type GetWorkspaceServiceAccountsResponses = {
    /**
     * successful operation
     */
    200: Array<{
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    }>;
};

export type GetWorkspaceServiceAccountsResponse = GetWorkspaceServiceAccountsResponses[keyof GetWorkspaceServiceAccountsResponses];

export type CreateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type CreateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Service account client secret (only returned on creation)
         */
        client_secret?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type CreateWorkspaceServiceAccountResponse = CreateWorkspaceServiceAccountResponses[keyof CreateWorkspaceServiceAccountResponses];

export type DeleteWorkspaceServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type DeleteWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type DeleteWorkspaceServiceAccountResponse = DeleteWorkspaceServiceAccountResponses[keyof DeleteWorkspaceServiceAccountResponses];

export type UpdateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type UpdateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type UpdateWorkspaceServiceAccountResponse = UpdateWorkspaceServiceAccountResponses[keyof UpdateWorkspaceServiceAccountResponses];

export type ListApiKeysForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type ListApiKeysForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: Array<ApiKey>;
};

export type ListApiKeysForServiceAccountResponse = ListApiKeysForServiceAccountResponses[keyof ListApiKeysForServiceAccountResponses];

export type CreateApiKeyForServiceAccountData = {
    body: {
        /**
         * Expiration period for the API key
         */
        expires_in?: string;
        /**
         * Name for the API key
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type CreateApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: ApiKey;
};

export type CreateApiKeyForServiceAccountResponse = CreateApiKeyForServiceAccountResponses[keyof CreateApiKeyForServiceAccountResponses];

export type DeleteApiKeyForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
        /**
         * Api key id
         */
        apiKeyId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys/{apiKeyId}';
};

export type DeleteApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/templates';
};

export type ListTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<Template>;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the template
         */
        templateName: string;
    };
    query?: never;
    url: '/templates/{templateName}';
};

export type GetTemplateResponses = {
    /**
     * successful operation
     */
    200: Template;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type ListWorkspaceUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/users';
};

export type ListWorkspaceUsersResponses = {
    /**
     * successful operation
     */
    200: Array<WorkspaceUser>;
};

export type ListWorkspaceUsersResponse = ListWorkspaceUsersResponses[keyof ListWorkspaceUsersResponses];

export type InviteWorkspaceUserData = {
    /**
     * Email of the user to invite
     */
    body: {
        email?: string;
    };
    path?: never;
    query?: never;
    url: '/users';
};

export type InviteWorkspaceUserErrors = {
    /**
     * invalid email format
     */
    400: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type InviteWorkspaceUserResponses = {
    /**
     * successful operation
     */
    200: PendingInvitation;
};

export type InviteWorkspaceUserResponse = InviteWorkspaceUserResponses[keyof InviteWorkspaceUserResponses];

export type RemoveWorkspaceUserData = {
    body?: never;
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type RemoveWorkspaceUserErrors = {
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type RemoveWorkspaceUserResponses = {
    /**
     * User successfully removed or invitation revoked
     */
    200: unknown;
};

export type UpdateWorkspaceUserRoleData = {
    body: {
        /**
         * The new role to assign to the user
         */
        role: string;
    };
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type UpdateWorkspaceUserRoleErrors = {
    /**
     * Invalid role provided
     */
    400: unknown;
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type UpdateWorkspaceUserRoleResponses = {
    /**
     * User role updated successfully
     */
    200: WorkspaceUser;
};

export type UpdateWorkspaceUserRoleResponse = UpdateWorkspaceUserRoleResponses[keyof UpdateWorkspaceUserRoleResponses];

export type ListVolumesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type ListVolumesResponses = {
    /**
     * successful operation
     */
    200: Array<Volume>;
};

export type ListVolumesResponse = ListVolumesResponses[keyof ListVolumesResponses];

export type CreateVolumeData = {
    body: Volume;
    path?: never;
    query?: never;
    url: '/volumes';
};

export type CreateVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type CreateVolumeResponse = CreateVolumeResponses[keyof CreateVolumeResponses];

export type DeleteVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type DeleteVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type DeleteVolumeResponse = DeleteVolumeResponses[keyof DeleteVolumeResponses];

export type GetVolumeData = {
    body?: never;
    path: {
        /**
         * Name of the volume
         */
        volumeName: string;
    };
    query?: never;
    url: '/volumes/{volumeName}';
};

export type GetVolumeResponses = {
    /**
     * successful operation
     */
    200: Volume;
};

export type GetVolumeResponse = GetVolumeResponses[keyof GetVolumeResponses];

export type ListWorkspacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type ListWorkspacesResponses = {
    /**
     * successful operation
     */
    200: Array<Workspace>;
};

export type ListWorkspacesResponse = ListWorkspacesResponses[keyof ListWorkspacesResponses];

export type CreateWorspaceData = {
    body: Workspace;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type CreateWorspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type CreateWorspaceResponse = CreateWorspaceResponses[keyof CreateWorspaceResponses];

export type DeleteWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type DeleteWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type DeleteWorkspaceResponse = DeleteWorkspaceResponses[keyof DeleteWorkspaceResponses];

export type GetWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type GetWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type GetWorkspaceResponse = GetWorkspaceResponses[keyof GetWorkspaceResponses];

export type UpdateWorkspaceData = {
    body: Workspace;
    path: {
        /**
         * name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type UpdateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type UpdateWorkspaceResponse = UpdateWorkspaceResponses[keyof UpdateWorkspaceResponses];

export type DeclineWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/decline';
};

export type DeclineWorkspaceInvitationResponses = {
    /**
     * Invitation successfully declined
     */
    200: PendingInvitation;
};

export type DeclineWorkspaceInvitationResponse = DeclineWorkspaceInvitationResponses[keyof DeclineWorkspaceInvitationResponses];

export type AcceptWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/join';
};

export type AcceptWorkspaceInvitationErrors = {
    /**
     * Workspace or invitation not found
     */
    404: unknown;
};

export type AcceptWorkspaceInvitationResponses = {
    /**
     * Invitation successfully accepted
     */
    200: PendingInvitationAccept;
};

export type AcceptWorkspaceInvitationResponse = AcceptWorkspaceInvitationResponses[keyof AcceptWorkspaceInvitationResponses];

export type LeaveWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/leave';
};

export type LeaveWorkspaceErrors = {
    /**
     * Workspace not found
     */
    404: unknown;
};

export type LeaveWorkspaceResponses = {
    /**
     * Workspace successfully left
     */
    200: Workspace;
};

export type LeaveWorkspaceResponse = LeaveWorkspaceResponses[keyof LeaveWorkspaceResponses];

export type CheckWorkspaceAvailabilityData = {
    body: {
        name: string;
    };
    path?: never;
    query?: never;
    url: '/workspaces/availability';
};

export type CheckWorkspaceAvailabilityResponses = {
    /**
     * successful operation
     */
    200: boolean;
};

export type CheckWorkspaceAvailabilityResponse = CheckWorkspaceAvailabilityResponses[keyof CheckWorkspaceAvailabilityResponses];

export type ClientOptions = {
    baseUrl: 'https://api.blaxel.ai/v0' | 'https://run.blaxel.ai' | (string & {});
};
