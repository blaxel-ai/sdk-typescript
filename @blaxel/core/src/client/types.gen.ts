/* eslint-disable */
// This file is auto-generated by @hey-api/openapi-ts

/**
 * ACL
 */
export type Acl = TimeFields & {
    /**
     * ACL id
     */
    id?: string;
    /**
     * Resource ID
     */
    resource_id?: string;
    /**
     * Resource type
     */
    resource_type?: string;
    /**
     * Role
     */
    role?: string;
    /**
     * Subject ID
     */
    subject_id?: string;
    /**
     * Subject type
     */
    subject_type?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Agent
 */
export type Agent = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: AgentSpec;
    /**
     * Agent status
     */
    status?: string;
};

/**
 * Agent specification
 */
export type AgentSpec = CoreSpec & {
    /**
     * Description, small description computed from the prompt
     */
    description?: string;
    functions?: FunctionsList;
    /**
     * Knowledgebase Name
     */
    knowledgebase?: string;
    /**
     * Model name
     */
    model?: string;
    /**
     * Prompt, describe what your agent does
     */
    prompt?: string;
    repository?: Repository;
    /**
     * Store id
     */
    storeId?: string;
    triggers?: Triggers;
};

/**
 * Long-lived API key for accessing Blaxel
 */
export type ApiKey = TimeFields & OwnerFields & {
    /**
     * Api key
     */
    apiKey?: string;
    /**
     * Duration until expiration (in seconds)
     */
    expires_in?: string;
    /**
     * Api key id, to retrieve it from the API
     */
    id?: string;
    /**
     * Name for the API key
     */
    name?: string;
    /**
     * User subject identifier
     */
    sub?: string;
    /**
     * Subject type
     */
    sub_type?: string;
};

/**
 * Array of metrics
 */
export type ArrayMetric = Array<Metric>;

/**
 * Configuration
 */
export type Configuration = {
    /**
     * Continents
     */
    continents?: Array<unknown>;
    /**
     * Countries
     */
    countries?: Array<unknown>;
    /**
     * Private locations managed with blaxel operator
     */
    privateLocations?: Array<unknown>;
};

/**
 * Continent
 */
export type Continent = {
    /**
     * Continent display name
     */
    displayName?: string;
    /**
     * Continent code
     */
    name?: string;
};

/**
 * Core event
 */
export type CoreEvent = {
    /**
     * Event message
     */
    message?: string;
    /**
     * RevisionID link to the event
     */
    revision?: string;
    /**
     * Event status
     */
    status?: string;
    /**
     * Event time
     */
    time?: string;
    /**
     * Event type
     */
    type?: string;
};

/**
 * Core events
 */
export type CoreEvents = Array<CoreEvent>;

/**
 * Core specification
 */
export type CoreSpec = {
    /**
     * Optional configurations for the object
     */
    configurations?: {
        key?: SpecConfiguration;
    };
    /**
     * Enable or disable the resource
     */
    enabled?: boolean;
    flavors?: Flavors;
    integrationConnections?: IntegrationConnectionsList;
    policies?: PoliciesList;
    privateClusters?: ModelPrivateCluster;
    revision?: RevisionConfiguration;
    runtime?: Runtime;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
};

/**
 * Configuration
 */
export type Country = {
    /**
     * Country display name
     */
    displayName?: string;
    /**
     * Country code
     */
    name?: string;
};

/**
 * Entrypoint of the artifact
 */
export type Entrypoint = {
    /**
     * Args of the entrypoint
     */
    args?: Array<unknown>;
    /**
     * Command of the entrypoint
     */
    command?: string;
    /**
     * Env of the entrypoint
     */
    env?: {
        [key: string]: unknown;
    };
};

/**
 * A type of hardware available for deployments
 */
export type Flavor = {
    /**
     * Flavor name (e.g. t4)
     */
    name?: string;
    /**
     * Flavor type (e.g. cpu, gpu)
     */
    type?: string;
};

/**
 * Types of hardware available for deployments
 */
export type Flavors = Array<Flavor>;

/**
 * Form of the artifact
 */
export type Form = {
    /**
     * Config of the artifact
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * OAuth of the artifact
     */
    oauth?: {
        [key: string]: unknown;
    };
    /**
     * Secrets of the artifact
     */
    secrets?: {
        [key: string]: unknown;
    };
};

/**
 * Function
 */
export type _Function = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: FunctionSpec;
    /**
     * Function status
     */
    status?: string;
};

/**
 * Function kit
 */
export type FunctionKit = {
    /**
     * Description of the function kit, very important for the agent to work with your kit
     */
    description?: string;
    /**
     * The kit name, very important for the agent to work with your kit
     */
    name?: string;
    schema?: FunctionSchema;
};

/**
 * Function schema
 */
export type FunctionSchema = {
    /**
     * List of schemas that this schema extends
     */
    allOf?: Array<unknown>;
    /**
     * List of possible schemas, any of which this schema could be
     */
    anyOf?: Array<unknown>;
    /**
     * Description of the schema
     */
    description?: string;
    /**
     * Enum values
     */
    enum?: Array<string>;
    /**
     * Format of the schema
     */
    format?: string;
    items?: FunctionSchema;
    /**
     * Maximum length for string types
     */
    maxLength?: number;
    /**
     * Maximum value for number types
     */
    maximum?: number;
    /**
     * Minimum length for string types
     */
    minLength?: number;
    /**
     * Minimum value for number types
     */
    minimum?: number;
    /**
     * Schema that this schema must not be
     */
    not?: {
        [key: string]: unknown;
    };
    /**
     * List of schemas, one of which this schema must be
     */
    oneOf?: Array<unknown>;
    /**
     * Pattern for string types
     */
    pattern?: string;
    /**
     * Properties of the schema
     */
    properties?: {
        [key: string]: FunctionSchema;
    };
    /**
     * Required properties of the schema
     */
    required?: Array<string>;
    /**
     * Title of the schema
     */
    title?: string;
    /**
     * Type of the schema
     */
    type?: string;
};

/**
 * Helper type for AdditionalProperties which can be either a boolean or a schema
 */
export type FunctionSchemaOrBool = {
    [key: string]: unknown;
};

/**
 * Function specification
 */
export type FunctionSpec = CoreSpec & {
    /**
     * Function description, very important for the agent function to work with an LLM
     */
    description?: string;
    /**
     * Function kits
     */
    kit?: Array<FunctionKit>;
    schema?: FunctionSchema;
};

export type FunctionsList = Array<string>;

/**
 * Histogram bucket
 */
export type HistogramBucket = {
    /**
     * Count
     */
    count?: number;
    /**
     * End
     */
    end?: number;
    /**
     * Start
     */
    start?: number;
};

/**
 * Histogram stats
 */
export type HistogramStats = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
};

/**
 * Integration Connection
 */
export type IntegrationConnection = {
    metadata?: Metadata;
    spec?: IntegrationConnectionSpec;
};

/**
 * Integration connection specification
 */
export type IntegrationConnectionSpec = {
    /**
     * Additional configuration for the integration
     */
    config?: {
        [key: string]: string;
    };
    /**
     * Integration type
     */
    integration?: string;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Integration secret
     */
    secret?: {
        [key: string]: string;
    };
};

export type IntegrationConnectionsList = Array<string>;

/**
 * Model obtained from an external authentication provider, such as HuggingFace, OpenAI, etc...
 */
export type IntegrationModel = {
    /**
     * Provider model author
     */
    author?: string;
    /**
     * Provider model created at
     */
    created_at?: string;
    /**
     * Provider model downloads
     */
    downloads?: number;
    /**
     * Model endpoint URL
     */
    endpoint?: string;
    /**
     * Provider model ID
     */
    id?: string;
    /**
     * Provider model library name
     */
    library_name?: string;
    /**
     * Provider model likes
     */
    likes?: number;
    /**
     * Is the model private
     */
    model_private?: string;
    /**
     * Provider model name
     */
    name?: string;
    /**
     * Provider model pipeline tag
     */
    pipeline_tag?: string;
    /**
     * Provider model tags
     */
    tags?: Array<string>;
    /**
     * Provider model trending score
     */
    trending_score?: number;
};

/**
 * Integration repository
 */
export type IntegrationRepository = {
    /**
     * Repository ID
     */
    id?: string;
    /**
     * Whether the repository has Blaxel imports
     */
    isBl?: boolean;
    /**
     * Repository name
     */
    name?: string;
    /**
     * Repository owner
     */
    organization?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Knowledgebase
 */
export type Knowledgebase = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: KnowledgebaseSpec;
    /**
     * Knowledgebase status
     */
    status?: string;
};

/**
 * Knowledgebase specification
 */
export type KnowledgebaseSpec = {
    /**
     * Collection name
     */
    collectionName?: string;
    /**
     * Embedding model
     */
    embeddingModel?: string;
    /**
     * Embedding model type
     */
    embeddingModelType?: string;
    /**
     * Enable or disable the agent
     */
    enabled?: boolean;
    integrationConnections?: IntegrationConnectionsList;
    /**
     * Options specific to the knowledge base
     */
    options?: {
        [key: string]: string;
    };
    policies?: PoliciesList;
    revision?: RevisionConfiguration;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
};

export type KnowledgebasesList = Array<string>;

/**
 * Last N requests
 */
export type LastNRequestsMetric = {
    /**
     * Timestamp
     */
    date?: string;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Latency metrics
 */
export type LatencyMetric = {
    globalHistogram?: HistogramBucket;
    globalStats?: HistogramStats;
    histogramPerCode?: HistogramBucket;
    statsPerCode?: HistogramStats;
};

/**
 * Location availability for policies
 */
export type LocationResponse = {
    /**
     * Continent of the location
     */
    continent?: string;
    /**
     * Country of the location
     */
    country?: string;
    /**
     * Hardware flavors available in the location
     */
    flavors?: Array<Flavor>;
    /**
     * Name of the location
     */
    location?: string;
    /**
     * Status of the location
     */
    status?: string;
};

/**
 * Definition of an MCP from the MCP Hub
 */
export type McpDefinition = TimeFields & {
    /**
     * Categories of the artifact
     */
    categories?: Array<unknown>;
    /**
     * If the artifact is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the artifact
     */
    description?: string;
    /**
     * Display name of the artifact
     */
    displayName?: string;
    /**
     * If the artifact is enterprise
     */
    enterprise?: boolean;
    /**
     * Entrypoint of the artifact
     */
    entrypoint?: {
        [key: string]: unknown;
    };
    /**
     * Form of the artifact
     */
    form?: {
        [key: string]: unknown;
    };
    /**
     * Hidden secrets of the artifact
     */
    hiddenSecrets?: Array<string>;
    /**
     * Icon of the artifact
     */
    icon?: string;
    /**
     * Image of the artifact
     */
    image?: string;
    /**
     * Integration of the artifact
     */
    integration?: string;
    /**
     * Long description of the artifact
     */
    longDescription?: string;
    /**
     * Name of the artifact
     */
    name?: string;
    /**
     * URL of the artifact
     */
    url?: string;
};

/**
 * Metrics for memory allocation
 */
export type MemoryAllocationMetric = {
    /**
     * Total memory allocation in GB-seconds
     */
    totalAllocation?: number;
};

/**
 * Metadata
 */
export type Metadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    labels?: MetadataLabels;
    /**
     * Model name
     */
    name?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Labels
 */
export type MetadataLabels = {
    [key: string]: string;
};

/**
 * Metric
 */
export type Metric = {
    /**
     * Metric value
     */
    rate?: number;
    /**
     * Metric value
     */
    requestTotal?: number;
    /**
     * Metric timestamp
     */
    timestamp?: string;
};

/**
 * Metrics for resources
 */
export type Metrics = {
    /**
     * Metrics for agents
     */
    agents?: unknown;
    /**
     * Metrics for functions
     */
    functions?: unknown;
    /**
     * Historical requests for all resources globally
     */
    inferenceGlobal?: Array<unknown>;
    /**
     * Historical requests for all resources globally
     */
    items?: Array<unknown>;
    /**
     * Metric value
     */
    lastNRequests?: number;
    /**
     * Metrics for models
     */
    models?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for all resources globally
     */
    requestTotal?: number;
    /**
     * Number of requests for all resources globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for all resources globally
     */
    rps?: number;
    /**
     * Number of requests per second for all resources globally per code
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
};

/**
 * Logical object representing a model
 */
export type Model = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: ModelSpec;
    /**
     * Model status
     */
    status?: string;
};

/**
 * Private cluster where the model deployment is deployed
 */
export type ModelPrivateCluster = {
    /**
     * The base url of the model in the private cluster
     */
    baseUrl?: string;
    /**
     * If true, the private cluster is available
     */
    enabled?: boolean;
    /**
     * The name of the private cluster
     */
    name?: string;
};

/**
 * Model specification
 */
export type ModelSpec = CoreSpec & unknown;

/**
 * OAuth of the artifact
 */
export type OAuth = {
    /**
     * Scope of the OAuth
     */
    scope?: Array<unknown>;
    /**
     * Type of the OAuth
     */
    type?: string;
};

/**
 * Owner fields for Persistance
 */
export type OwnerFields = {
    /**
     * The user or service account who created the resource
     */
    createdBy?: string;
    /**
     * The user or service account who updated the resource
     */
    updatedBy?: string;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitation = TimeFields & OwnerFields & {
    /**
     * User email
     */
    email?: string;
    /**
     * User sub
     */
    invitedBy?: string;
    /**
     * ACL role
     */
    role?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Pending invitation accept
 */
export type PendingInvitationAccept = {
    /**
     * User email
     */
    email?: string;
    workspace?: Workspace;
};

/**
 * Pending invitation in workspace
 */
export type PendingInvitationRender = {
    /**
     * User email
     */
    email?: string;
    /**
     * Invitation date
     */
    invitedAt?: string;
    invitedBy?: PendingInvitationRenderInvitedBy;
    /**
     * ACL role
     */
    role?: string;
    workspace?: PendingInvitationRenderWorkspace;
    workspaceDetails?: PendingInvitationWorkspaceDetails;
};

/**
 * Invited by
 */
export type PendingInvitationRenderInvitedBy = {
    /**
     * User email
     */
    email?: string;
    /**
     * User family name
     */
    family_name?: string;
    /**
     * User given name
     */
    given_name?: string;
    /**
     * User sub
     */
    sub?: string;
};

/**
 * Workspace
 */
export type PendingInvitationRenderWorkspace = {
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Workspace name
     */
    name?: string;
};

/**
 * Workspace details
 */
export type PendingInvitationWorkspaceDetails = {
    /**
     * List of user emails in the workspace
     */
    emails?: Array<unknown>;
    /**
     * Number of users in the workspace
     */
    user_number?: number;
};

/**
 * Pod template specification
 */
export type PodTemplateSpec = {
    [key: string]: unknown;
};

export type PoliciesList = Array<string>;

/**
 * Rule that controls how a deployment is made and served (e.g. location restrictions)
 */
export type Policy = {
    metadata?: Metadata;
    spec?: PolicySpec;
};

/**
 * Policy location
 */
export type PolicyLocation = {
    /**
     * Policy location name
     */
    name?: string;
    /**
     * Policy location type
     */
    type?: string;
};

/**
 * PolicyLocations is a local type that wraps a slice of Location
 */
export type PolicyLocations = Array<PolicyLocation>;

/**
 * PolicyMaxTokens is a local type that wraps a slice of PolicyMaxTokens
 */
export type PolicyMaxTokens = {
    /**
     * Granularity
     */
    granularity?: string;
    /**
     * Input
     */
    input?: number;
    /**
     * Output
     */
    output?: number;
    /**
     * RatioInputOverOutput
     */
    ratioInputOverOutput?: number;
    /**
     * Step
     */
    step?: number;
    /**
     * Total
     */
    total?: number;
};

/**
 * PolicyResourceType is a type of resource, e.g. model, function, etc.
 */
export type PolicyResourceType = string;

/**
 * PolicyResourceTypes is a local type that wraps a slice of PolicyResourceType
 */
export type PolicyResourceTypes = Array<PolicyResourceType>;

/**
 * Policy specification
 */
export type PolicySpec = {
    flavors?: Flavors;
    locations?: PolicyLocations;
    maxTokens?: PolicyMaxTokens;
    resourceTypes?: PolicyResourceTypes;
    /**
     * Sandbox mode
     */
    sandbox?: boolean;
    /**
     * Policy type, can be location or flavor
     */
    type?: string;
};

/**
 * A port for a resource
 */
export type Port = {
    /**
     * The name of the port
     */
    name?: string;
    /**
     * The protocol of the port
     */
    protocol?: string;
    /**
     * The target port of the port
     */
    target?: number;
};

/**
 * Set of ports for a resource
 */
export type Ports = Array<Port>;

/**
 * Preview of a Resource
 */
export type Preview = {
    metadata?: PreviewMetadata;
    spec?: PreviewSpec;
};

/**
 * PreviewMetadata
 */
export type PreviewMetadata = TimeFields & OwnerFields & {
    /**
     * Model display name
     */
    displayName?: string;
    /**
     * Preview name
     */
    name?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Preview of a Resource
 */
export type PreviewSpec = {
    /**
     * Port of the preview
     */
    port?: number;
    /**
     * Whether the preview is public
     */
    public?: boolean;
    /**
     * URL of the preview
     */
    url?: string;
};

/**
 * Token for a Preview
 */
export type PreviewToken = {
    metadata?: PreviewTokenMetadata;
    spec?: PreviewTokenSpec;
};

/**
 * PreviewTokenMetadata
 */
export type PreviewTokenMetadata = {
    /**
     * Token name
     */
    name?: string;
    /**
     * Preview name
     */
    previewName?: string;
    /**
     * Resource name
     */
    resourceName?: string;
    /**
     * Resource type
     */
    resourceType?: string;
    /**
     * Workspace name
     */
    workspace?: string;
};

/**
 * Spec for a Preview Token
 */
export type PreviewTokenSpec = {
    /**
     * Whether the token is expired
     */
    expired?: boolean;
    /**
     * Expiration time of the token
     */
    expiresAt?: string;
    /**
     * JWT token
     */
    jwt?: string;
    /**
     * Whether the token is public
     */
    public?: boolean;
};

/**
 * A private cluster where models can be located on.
 */
export type PrivateCluster = TimeFields & OwnerFields & {
    /**
     * The private cluster's continent, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    continent?: string;
    /**
     * The country where the private cluster is located, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    country?: string;
    /**
     * The private cluster's display Name
     */
    displayName?: string;
    /**
     * Whether the private cluster is healthy or not, used to determine if the private cluster is ready to run inference
     */
    healthy?: boolean;
    /**
     * The private cluster's unique name
     */
    lastHealthCheckTime?: string;
    /**
     * The private cluster's latitude, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    latitude?: string;
    /**
     * The private cluster's longitude, used to determine the closest private cluster to serve inference requests based on the user's location
     */
    longitude?: string;
    /**
     * The name of the private cluster, it must be unique
     */
    name?: string;
    /**
     * The service account (operator) that owns the cluster
     */
    ownedBy?: string;
    /**
     * The workspace the private cluster belongs to
     */
    workspace?: string;
};

/**
 * Private location available for policies
 */
export type PrivateLocation = {
    /**
     * Location name
     */
    name?: string;
};

/**
 * Repository
 */
export type Repository = {
    /**
     * Repository type
     */
    type?: string;
    /**
     * Repository URL
     */
    url?: string;
};

/**
 * Request duration over time metric
 */
export type RequestDurationOverTimeMetric = {
    /**
     * Average request duration
     */
    average?: number;
    /**
     * P50 request duration
     */
    p50?: number;
    /**
     * P90 request duration
     */
    p90?: number;
    /**
     * P99 request duration
     */
    p99?: number;
    /**
     * Timestamp
     */
    timestamp?: string;
};

/**
 * Request duration over time metrics
 */
export type RequestDurationOverTimeMetrics = {
    requestDurationOverTime?: RequestDurationOverTimeMetric;
};

/**
 * Request total by origin metric
 */
export type RequestTotalByOriginMetric = {
    /**
     * Request total by origin
     */
    requestTotalByOrigin?: {
        [key: string]: unknown;
    };
    /**
     * Request total by origin and code
     */
    requestTotalByOriginAndCode?: {
        [key: string]: unknown;
    };
};

/**
 * Metrics for request total
 */
export type RequestTotalMetric = {
    /**
     * Historical requests for all resources globally
     */
    items?: Array<unknown>;
    /**
     * Number of requests for all resources globally
     */
    requestTotal?: number;
    /**
     * Number of requests for all resources globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for all resources globally
     */
    rps?: number;
    /**
     * Number of requests for all resources globally
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
};

/**
 * Request total response data
 */
export type RequestTotalResponseData = {
    /**
     * Request total
     */
    requestTotal?: number;
    /**
     * Status code
     */
    statusCode?: string;
    /**
     * Workload ID
     */
    workloadId?: string;
    /**
     * Workload type
     */
    workloadType?: string;
    /**
     * Workspace
     */
    workspace?: string;
};

/**
 * Log for a resource deployment (eg. model deployment, function deployment)
 */
export type ResourceLog = {
    /**
     * Content of the log
     */
    message?: string;
    /**
     * Severity of the log
     */
    severity?: number;
    /**
     * The timestamp of the log
     */
    timestamp?: string;
    /**
     * Trace ID of the log
     */
    trace_id?: string;
};

/**
 * Metrics for a single resource deployment (eg. model deployment, function deployment)
 */
export type ResourceMetrics = {
    inferenceErrorsGlobal?: ArrayMetric;
    inferenceGlobal?: ArrayMetric;
    lastNRequests?: ArrayMetric;
    latency?: LatencyMetric;
    latencyPrevious?: LatencyMetric;
    memoryAllocation?: MemoryAllocationMetric;
    modelTtft?: LatencyMetric;
    modelTtftOverTime?: TimeToFirstTokenOverTimeMetrics;
    requestDurationOverTime?: RequestDurationOverTimeMetrics;
    /**
     * Number of requests for the resource globally
     */
    requestTotal?: number;
    requestTotalByOrigin?: RequestTotalByOriginMetric;
    requestTotalByOriginPrevious?: RequestTotalByOriginMetric;
    /**
     * Number of requests for the resource globally per code
     */
    requestTotalPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for the resource globally per code for the previous period
     */
    requestTotalPerCodePrevious?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests for the resource globally for the previous period
     */
    requestTotalPrevious?: number;
    /**
     * Number of requests per second for the resource globally
     */
    rps?: number;
    /**
     * Number of requests per second for the resource globally per code
     */
    rpsPerCode?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for the resource globally per code for the previous period
     */
    rpsPerCodePrevious?: {
        [key: string]: unknown;
    };
    /**
     * Number of requests per second for the resource globally for the previous period
     */
    rpsPrevious?: number;
    tokenRate?: TokenRateMetrics;
    tokenTotal?: TokenTotalMetric;
};

/**
 * Revision configuration
 */
export type RevisionConfiguration = {
    /**
     * Active revision id
     */
    active?: string;
    /**
     * Canary revision id
     */
    canary?: string;
    /**
     * Canary revision percent
     */
    canaryPercent?: number;
    /**
     * Traffic percentage
     */
    traffic?: number;
};

/**
 * Revision metadata
 */
export type RevisionMetadata = {
    /**
     * Is the revision active
     */
    active?: boolean;
    /**
     * Is the revision canary
     */
    canary?: boolean;
    /**
     * Revision created at
     */
    createdAt?: string;
    /**
     * Revision created by
     */
    createdBy?: string;
    /**
     * Revision ID
     */
    id?: string;
    /**
     * Is the revision previous active
     */
    previousActive?: boolean;
    /**
     * Status of the revision
     */
    status?: string;
    /**
     * Percent of traffic to the revision
     */
    trafficPercent?: number;
};

/**
 * Set of configurations for a deployment
 */
export type Runtime = {
    /**
     * The arguments to pass to the deployment runtime
     */
    args?: Array<unknown>;
    /**
     * The command to run the deployment
     */
    command?: Array<unknown>;
    /**
     * The configuration for the deployment
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * The CPU for the deployment in cores, only available for private cluster
     */
    cpu?: number;
    /**
     * Endpoint Name of the model. In case of hf_private_endpoint, it is the endpoint name. In case of hf_public_endpoint, it is not used.
     */
    endpointName?: string;
    /**
     * The env variables to set in the deployment. Should be a list of Kubernetes EnvVar types
     */
    envs?: Array<unknown>;
    /**
     * The generation of the deployment
     */
    generation?: string;
    /**
     * The Docker image for the deployment
     */
    image?: string;
    /**
     * The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
     */
    maxScale?: number;
    /**
     * The memory for the deployment in MB
     */
    memory?: number;
    /**
     * The port to serve the metrics on
     */
    metricPort?: number;
    /**
     * The maximum number of replicas for the deployment.
     */
    minScale?: number;
    /**
     * The slug name of the origin model at HuggingFace.
     */
    model?: string;
    /**
     * The organization of the model
     */
    organization?: string;
    ports?: Ports;
    /**
     * The readiness probe. Should be a Kubernetes Probe type
     */
    startupProbe?: {
        [key: string]: unknown;
    };
    /**
     * The timeout for the deployment in seconds
     */
    timeout?: number;
    /**
     * The type of origin for the deployment (hf_private_endpoint, hf_public_endpoint)
     */
    type?: string;
};

/**
 * Micro VM for running agentic tasks
 */
export type Sandbox = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: SandboxSpec;
    /**
     * Sandbox status
     */
    status?: string;
};

/**
 * Sandbox definition for admin store operations
 */
export type SandboxDefinition = {
    /**
     * Categories of the defintion
     */
    categories?: Array<unknown>;
    /**
     * If the definition is coming soon
     */
    coming_soon?: boolean;
    /**
     * Description of the defintion
     */
    description?: string;
    /**
     * Display name of the definition
     */
    displayName?: string;
    /**
     * If the definition is enterprise
     */
    enterprise?: boolean;
    /**
     * Icon of the definition
     */
    icon?: string;
    /**
     * Image of the Sandbox definition
     */
    image?: string;
    /**
     * Long description of the defintion
     */
    longDescription?: string;
    /**
     * Memory of the Sandbox definition in MB
     */
    memory?: number;
    /**
     * Name of the artifact
     */
    name?: string;
    ports?: Ports;
    /**
     * URL of the definition
     */
    url?: string;
};

/**
 * Sandbox specification
 */
export type SandboxSpec = CoreSpec & unknown;

/**
 * Name of a Sandbox definition
 */
export type SandboxStoreDefinitionName = unknown;

/**
 * Micro VM for running agentic tasks
 */
export type Sandboxes = {
    events?: CoreEvents;
    metadata?: Metadata;
    spec?: SandboxSpec;
    /**
     * Sandbox status
     */
    status?: string;
};

/**
 * Configuration for a serverless deployment
 */
export type ServerlessConfig = {
    /**
     * The configuration for the deployment
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * The minimum number of replicas for the deployment. Can be 0 or 1 (in which case the deployment is always running in at least one location).
     */
    maxScale?: number;
    /**
     * The maximum number of replicas for the deployment.
     */
    minScale?: number;
    /**
     * The timeout for the deployment in seconds
     */
    timeout?: number;
};

/**
 * Configuration, this is a key value storage. In your object you can retrieve the value with config[key]
 */
export type SpecConfiguration = {
    /**
     * ACconfiguration secret
     */
    secret?: boolean;
    /**
     * Configuration value
     */
    value?: string;
};

/**
 * Response when starting a Sandbox
 */
export type StartSandbox = {
    /**
     * Human readable message about the start operation
     */
    message?: string;
    metadata?: Metadata;
    /**
     * Status of the Sandbox start operation
     */
    status?: string;
};

/**
 * Response when stopping a Sandbox
 */
export type StopSandbox = {
    /**
     * Human readable message about the stop operation
     */
    message?: string;
    metadata?: Metadata;
    /**
     * Status of the Sandbox stop operation
     */
    status?: string;
};

/**
 * Store agent
 */
export type StoreAgent = TimeFields & OwnerFields & {
    /**
     * Store agent configuration
     */
    configuration?: Array<StoreConfiguration>;
    /**
     * Store agent description
     */
    description?: string;
    /**
     * Store agent display name
     */
    displayName?: string;
    /**
     * Store agent image
     */
    image?: string;
    /**
     * Store agent labels
     */
    labels?: {
        [key: string]: unknown;
    };
    /**
     * Store agent name
     */
    name?: string;
    /**
     * Store agent prompt, this is to define what the agent does
     */
    prompt?: string;
};

/**
 * Store configuration for resources (eg: agent, function, etc)
 */
export type StoreConfiguration = {
    /**
     * Available models for the configuration
     */
    availableModels?: Array<string>;
    /**
     * Store configuration description
     */
    description?: string;
    /**
     * Store configuration display name
     */
    displayName?: string;
    /**
     * Conditional rendering for the configuration, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration name
     */
    name?: string;
    options?: Array<StoreConfigurationOption>;
    /**
     * Store configuration required
     */
    required?: boolean;
    /**
     * Store configuration secret
     */
    secret?: boolean;
    /**
     * Store configuration type
     */
    type?: string;
};

/**
 * Store configuration options for a select type configuration
 */
export type StoreConfigurationOption = {
    /**
     * Conditional rendering for the configuration option, example: provider === 'openai'
     */
    if?: string;
    /**
     * Store configuration option label
     */
    label?: string;
    /**
     * Store configuration option value
     */
    value?: string;
};

/**
 * Blaxel template
 */
export type Template = {
    /**
     * Default branch of the template
     */
    defaultBranch?: string;
    /**
     * Description of the template
     */
    description?: string;
    /**
     * Number of downloads/clones of the repository
     */
    downloadCount?: number;
    /**
     * Number of forks the repository has
     */
    forksCount?: number;
    /**
     * URL to the template's icon
     */
    icon?: string;
    /**
     * URL to the template's icon in dark mode
     */
    iconDark?: string;
    /**
     * Name of the template
     */
    name?: string;
    /**
     * SHA of the variable
     */
    sha?: string;
    /**
     * Number of stars the repository has
     */
    starCount?: number;
    /**
     * Topic of the template
     */
    topics?: Array<string>;
    /**
     * URL of the template
     */
    url?: string;
    /**
     * Variables of the template
     */
    variables?: Array<TemplateVariable>;
};

/**
 * Blaxel template variable
 */
export type TemplateVariable = {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Integration of the variable
     */
    integration?: string;
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Path of the variable
     */
    path?: string;
    /**
     * Whether the variable is secret
     */
    secret?: boolean;
};

/**
 * Time fields for Persistance
 */
export type TimeFields = {
    /**
     * The date and time when the resource was created
     */
    createdAt?: string;
    /**
     * The date and time when the resource was updated
     */
    updatedAt?: string;
};

/**
 * Time to first token over time metrics
 */
export type TimeToFirstTokenOverTimeMetrics = {
    timeToFirstTokenOverTime?: RequestDurationOverTimeMetric;
};

/**
 * Token rate metric
 */
export type TokenRateMetric = {
    /**
     * Model ID
     */
    model?: string;
    /**
     * Provider name
     */
    provider?: string;
    /**
     * Provider integration name
     */
    providerName?: string;
    /**
     * Timestamp
     */
    timestamp?: string;
    /**
     * Total tokens
     */
    tokenTotal?: number;
    /**
     * Trend
     */
    trend?: number;
};

/**
 * Token rate metrics
 */
export type TokenRateMetrics = {
    tokenRate?: TokenRateMetric;
    tokenRateInput?: TokenRateMetric;
    tokenRateOutput?: TokenRateMetric;
};

/**
 * Token total metric
 */
export type TokenTotalMetric = {
    /**
     * Average input token per request
     */
    averageTokenInputPerRequest?: number;
    /**
     * Average output token per request
     */
    averageTokenOutputPerRequest?: number;
    /**
     * Average token per request
     */
    averageTokenPerRequest?: number;
    /**
     * Total input tokens
     */
    tokenInput?: number;
    /**
     * Total output tokens
     */
    tokenOutput?: number;
    /**
     * Total tokens
     */
    tokenTotal?: number;
};

/**
 * Trace IDs response
 */
export type TraceIdsResponse = {
    [key: string]: unknown;
};

/**
 * Trigger configuration
 */
export type Trigger = {
    /**
     * The configuration of the trigger
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * The id of the trigger
     */
    id?: string;
    /**
     * The type of trigger, can be http or http-async
     */
    type?: string;
};

/**
 * Triggers to use your agent
 */
export type Triggers = Array<Trigger>;

/**
 * WebSocket connection details
 */
export type WebsocketChannel = TimeFields & {
    /**
     * Unique connection ID
     */
    connection_id?: string;
    /**
     * Workspace the connection belongs to
     */
    workspace?: string;
};

/**
 * Workspace
 */
export type Workspace = TimeFields & OwnerFields & {
    /**
     * Workspace account id
     */
    accountId?: string;
    /**
     * Workspace display name
     */
    displayName?: string;
    /**
     * Workspace labels
     */
    labels?: {
        [key: string]: unknown;
    };
    /**
     * Workspace name
     */
    name?: string;
    /**
     * Workspace write region
     */
    region?: string;
    runtime?: WorkspaceRuntime;
};

/**
 * Workspace runtime
 */
export type WorkspaceRuntime = {
    /**
     * Workspace generation
     */
    generation?: string;
};

/**
 * Workspace user
 */
export type WorkspaceUser = {
    /**
     * Whether the user has accepted the workspace invitation
     */
    accepted?: boolean;
    /**
     * Workspace user email
     */
    email?: string;
    /**
     * Whether the user's email has been verified
     */
    email_verified?: boolean;
    /**
     * Workspace user family name
     */
    family_name?: string;
    /**
     * Workspace user given name
     */
    given_name?: string;
    /**
     * Workspace user role
     */
    role?: string;
    /**
     * Workspace user identifier
     */
    sub?: string;
};

export type ListAgentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/agents';
};

export type ListAgentsResponses = {
    /**
     * successful operation
     */
    200: Array<Agent>;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type CreateAgentData = {
    body: Agent;
    path?: never;
    query?: never;
    url: '/agents';
};

export type CreateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type DeleteAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type GetAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body: Agent;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}';
};

export type UpdateAgentResponses = {
    /**
     * successful operation
     */
    200: Agent;
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type ListAgentRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the agent
         */
        agentName: string;
    };
    query?: never;
    url: '/agents/{agentName}/revisions';
};

export type ListAgentRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListAgentRevisionsResponse = ListAgentRevisionsResponses[keyof ListAgentRevisionsResponses];

export type GetConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/configuration';
};

export type GetConfigurationResponses = {
    /**
     * Configuration of the control plane
     */
    200: Configuration;
};

export type GetConfigurationResponse = GetConfigurationResponses[keyof GetConfigurationResponses];

export type ListFunctionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/functions';
};

export type ListFunctionsResponses = {
    /**
     * successful operation
     */
    200: Array<_Function>;
};

export type ListFunctionsResponse = ListFunctionsResponses[keyof ListFunctionsResponses];

export type CreateFunctionData = {
    body: _Function;
    path?: never;
    query?: never;
    url: '/functions';
};

export type CreateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type CreateFunctionResponse = CreateFunctionResponses[keyof CreateFunctionResponses];

export type DeleteFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type DeleteFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type DeleteFunctionResponse = DeleteFunctionResponses[keyof DeleteFunctionResponses];

export type GetFunctionData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type GetFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type GetFunctionResponse = GetFunctionResponses[keyof GetFunctionResponses];

export type UpdateFunctionData = {
    body: _Function;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}';
};

export type UpdateFunctionResponses = {
    /**
     * successful operation
     */
    200: _Function;
};

export type UpdateFunctionResponse = UpdateFunctionResponses[keyof UpdateFunctionResponses];

export type ListFunctionRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the function
         */
        functionName: string;
    };
    query?: never;
    url: '/functions/{functionName}/revisions';
};

export type ListFunctionRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListFunctionRevisionsResponse = ListFunctionRevisionsResponses[keyof ListFunctionRevisionsResponses];

export type GetIntegrationData = {
    body?: never;
    path: {
        /**
         * Name of the integration
         */
        integrationName: string;
    };
    query?: never;
    url: '/integrations/{integrationName}';
};

export type GetIntegrationResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListIntegrationConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type ListIntegrationConnectionsResponses = {
    /**
     * successful operation
     */
    200: Array<IntegrationConnection>;
};

export type ListIntegrationConnectionsResponse = ListIntegrationConnectionsResponses[keyof ListIntegrationConnectionsResponses];

export type CreateIntegrationConnectionData = {
    body: IntegrationConnection;
    path?: never;
    query?: never;
    url: '/integrations/connections';
};

export type CreateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type CreateIntegrationConnectionResponse = CreateIntegrationConnectionResponses[keyof CreateIntegrationConnectionResponses];

export type DeleteIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type DeleteIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type DeleteIntegrationConnectionResponse = DeleteIntegrationConnectionResponses[keyof DeleteIntegrationConnectionResponses];

export type GetIntegrationConnectionData = {
    body?: never;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type GetIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type GetIntegrationConnectionResponse = GetIntegrationConnectionResponses[keyof GetIntegrationConnectionResponses];

export type UpdateIntegrationConnectionData = {
    body: IntegrationConnection;
    path: {
        /**
         * Name of the integrationconnection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}';
};

export type UpdateIntegrationConnectionResponses = {
    /**
     * successful operation
     */
    200: IntegrationConnection;
};

export type UpdateIntegrationConnectionResponse = UpdateIntegrationConnectionResponses[keyof UpdateIntegrationConnectionResponses];

export type GetIntegrationConnectionModelEndpointConfigurationsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/endpointConfigurations';
};

export type GetIntegrationConnectionModelEndpointConfigurationsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListIntegrationConnectionModelsData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models';
};

export type ListIntegrationConnectionModelsResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type GetIntegrationConnectionModelData = {
    body?: never;
    path: {
        /**
         * Name of the connection
         */
        connectionName: string;
        /**
         * Model ID
         */
        modelId: string;
    };
    query?: never;
    url: '/integrations/connections/{connectionName}/models/{modelId}';
};

export type GetIntegrationConnectionModelResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListKnowledgebasesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/knowledgebases';
};

export type ListKnowledgebasesResponses = {
    /**
     * successful operation
     */
    200: Array<Knowledgebase>;
};

export type ListKnowledgebasesResponse = ListKnowledgebasesResponses[keyof ListKnowledgebasesResponses];

export type CreateKnowledgebaseData = {
    body: Knowledgebase;
    path?: never;
    query?: never;
    url: '/knowledgebases';
};

export type CreateKnowledgebaseResponses = {
    /**
     * successful operation
     */
    200: Knowledgebase;
};

export type CreateKnowledgebaseResponse = CreateKnowledgebaseResponses[keyof CreateKnowledgebaseResponses];

export type DeleteKnowledgebaseData = {
    body?: never;
    path: {
        /**
         * Name of the knowledgebase
         */
        knowledgebaseName: string;
    };
    query?: never;
    url: '/knowledgebases/{knowledgebaseName}';
};

export type DeleteKnowledgebaseResponses = {
    /**
     * successful operation
     */
    200: Knowledgebase;
};

export type DeleteKnowledgebaseResponse = DeleteKnowledgebaseResponses[keyof DeleteKnowledgebaseResponses];

export type GetKnowledgebaseData = {
    body?: never;
    path: {
        /**
         * Name of the knowledgebase
         */
        knowledgebaseName: string;
    };
    query?: never;
    url: '/knowledgebases/{knowledgebaseName}';
};

export type GetKnowledgebaseResponses = {
    /**
     * successful operation
     */
    200: Knowledgebase;
};

export type GetKnowledgebaseResponse = GetKnowledgebaseResponses[keyof GetKnowledgebaseResponses];

export type UpdateKnowledgebaseData = {
    body: Knowledgebase;
    path: {
        /**
         * Name of the knowledgebase
         */
        knowledgebaseName: string;
    };
    query?: never;
    url: '/knowledgebases/{knowledgebaseName}';
};

export type UpdateKnowledgebaseResponses = {
    /**
     * successful operation
     */
    200: Knowledgebase;
};

export type UpdateKnowledgebaseResponse = UpdateKnowledgebaseResponses[keyof UpdateKnowledgebaseResponses];

export type ListKnowledgebaseRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the knowledgebase
         */
        knowledgebaseName: string;
    };
    query?: never;
    url: '/knowledgebases/{knowledgebaseName}/revisions';
};

export type ListKnowledgebaseRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListKnowledgebaseRevisionsResponse = ListKnowledgebaseRevisionsResponses[keyof ListKnowledgebaseRevisionsResponses];

export type ListLocationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/locations';
};

export type ListLocationsResponses = {
    /**
     * successful operation
     */
    200: Array<LocationResponse>;
};

export type ListLocationsResponse = ListLocationsResponses[keyof ListLocationsResponses];

export type ListMcpHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mcp/hub';
};

export type ListMcpHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<McpDefinition>;
};

export type ListMcpHubDefinitionsResponse = ListMcpHubDefinitionsResponses[keyof ListMcpHubDefinitionsResponses];

export type ListModelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/models';
};

export type ListModelsResponses = {
    /**
     * successful operation
     */
    200: Array<Model>;
};

export type ListModelsResponse = ListModelsResponses[keyof ListModelsResponses];

export type CreateModelData = {
    body: Model;
    path?: never;
    query?: never;
    url: '/models';
};

export type CreateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type CreateModelResponse = CreateModelResponses[keyof CreateModelResponses];

export type DeleteModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type DeleteModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type DeleteModelResponse = DeleteModelResponses[keyof DeleteModelResponses];

export type GetModelData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type GetModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type GetModelResponse = GetModelResponses[keyof GetModelResponses];

export type UpdateModelData = {
    body: Model;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}';
};

export type UpdateModelResponses = {
    /**
     * successful operation
     */
    200: Model;
};

export type UpdateModelResponse = UpdateModelResponses[keyof UpdateModelResponses];

export type ListModelRevisionsData = {
    body?: never;
    path: {
        /**
         * Name of the model
         */
        modelName: string;
    };
    query?: never;
    url: '/models/{modelName}/revisions';
};

export type ListModelRevisionsResponses = {
    /**
     * successful operation
     */
    200: Array<RevisionMetadata>;
};

export type ListModelRevisionsResponse = ListModelRevisionsResponses[keyof ListModelRevisionsResponses];

export type ListPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/policies';
};

export type ListPoliciesResponses = {
    /**
     * successful operation
     */
    200: Array<Policy>;
};

export type ListPoliciesResponse = ListPoliciesResponses[keyof ListPoliciesResponses];

export type CreatePolicyData = {
    body: Policy;
    path?: never;
    query?: never;
    url: '/policies';
};

export type CreatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type CreatePolicyResponse = CreatePolicyResponses[keyof CreatePolicyResponses];

export type DeletePolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type DeletePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type DeletePolicyResponse = DeletePolicyResponses[keyof DeletePolicyResponses];

export type GetPolicyData = {
    body?: never;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type GetPolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type GetPolicyResponse = GetPolicyResponses[keyof GetPolicyResponses];

export type UpdatePolicyData = {
    body: Policy;
    path: {
        /**
         * Name of the policy
         */
        policyName: string;
    };
    query?: never;
    url: '/policies/{policyName}';
};

export type UpdatePolicyResponses = {
    /**
     * successful operation
     */
    200: Policy;
};

export type UpdatePolicyResponse = UpdatePolicyResponses[keyof UpdatePolicyResponses];

export type ListPrivateClustersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/privateclusters';
};

export type ListPrivateClustersErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type ListPrivateClustersResponses = {
    /**
     * successful operation
     */
    200: Array<PrivateCluster>;
};

export type ListPrivateClustersResponse = ListPrivateClustersResponses[keyof ListPrivateClustersResponses];

export type CreatePrivateClusterData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/privateclusters';
};

export type CreatePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreatePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type CreatePrivateClusterResponse = CreatePrivateClusterResponses[keyof CreatePrivateClusterResponses];

export type DeletePrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type DeletePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeletePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type DeletePrivateClusterResponse = DeletePrivateClusterResponses[keyof DeletePrivateClusterResponses];

export type GetPrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type GetPrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * private cluster not found
     */
    404: unknown;
};

export type GetPrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type GetPrivateClusterResponse = GetPrivateClusterResponses[keyof GetPrivateClusterResponses];

export type UpdatePrivateClusterData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}';
};

export type UpdatePrivateClusterErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdatePrivateClusterResponses = {
    /**
     * successful operation
     */
    200: PrivateCluster;
};

export type UpdatePrivateClusterResponse = UpdatePrivateClusterResponses[keyof UpdatePrivateClusterResponses];

export type GetPrivateClusterHealthData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}/health';
};

export type GetPrivateClusterHealthErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetPrivateClusterHealthResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type UpdatePrivateClusterHealthData = {
    body?: never;
    path: {
        /**
         * Name of the private cluster
         */
        privateClusterName: string;
    };
    query?: never;
    url: '/privateclusters/{privateClusterName}/health';
};

export type UpdatePrivateClusterHealthErrors = {
    /**
     * unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type UpdatePrivateClusterHealthResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListAllPendingInvitationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/profile/invitations';
};

export type ListAllPendingInvitationsErrors = {
    /**
     * no pending invitations
     */
    404: unknown;
};

export type ListAllPendingInvitationsResponses = {
    /**
     * successful operation
     */
    200: Array<PendingInvitationRender>;
};

export type ListAllPendingInvitationsResponse = ListAllPendingInvitationsResponses[keyof ListAllPendingInvitationsResponses];

export type ListSandboxHubDefinitionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandbox/hub';
};

export type ListSandboxHubDefinitionsResponses = {
    /**
     * successful operation
     */
    200: Array<SandboxDefinition>;
};

export type ListSandboxHubDefinitionsResponse = ListSandboxHubDefinitionsResponses[keyof ListSandboxHubDefinitionsResponses];

export type ListSandboxesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type ListSandboxesResponses = {
    /**
     * successful operation
     */
    200: Array<Sandbox>;
};

export type ListSandboxesResponse = ListSandboxesResponses[keyof ListSandboxesResponses];

export type CreateSandboxData = {
    body: Sandbox;
    path?: never;
    query?: never;
    url: '/sandboxes';
};

export type CreateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type CreateSandboxResponse = CreateSandboxResponses[keyof CreateSandboxResponses];

export type DeleteSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type DeleteSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type DeleteSandboxResponse = DeleteSandboxResponses[keyof DeleteSandboxResponses];

export type GetSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type GetSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type GetSandboxResponse = GetSandboxResponses[keyof GetSandboxResponses];

export type UpdateSandboxData = {
    body: Sandbox;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}';
};

export type UpdateSandboxResponses = {
    /**
     * successful operation
     */
    200: Sandbox;
};

export type UpdateSandboxResponse = UpdateSandboxResponses[keyof UpdateSandboxResponses];

export type ListSandboxPreviewsData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type ListSandboxPreviewsResponses = {
    /**
     * successful operation
     */
    200: Array<Preview>;
};

export type ListSandboxPreviewsResponse = ListSandboxPreviewsResponses[keyof ListSandboxPreviewsResponses];

export type CreateSandboxPreviewData = {
    body: Preview;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews';
};

export type CreateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type CreateSandboxPreviewResponse = CreateSandboxPreviewResponses[keyof CreateSandboxPreviewResponses];

export type DeleteSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type DeleteSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type DeleteSandboxPreviewResponse = DeleteSandboxPreviewResponses[keyof DeleteSandboxPreviewResponses];

export type GetSandboxPreviewData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type GetSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type GetSandboxPreviewResponse = GetSandboxPreviewResponses[keyof GetSandboxPreviewResponses];

export type UpdateSandboxPreviewData = {
    body: Preview;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}';
};

export type UpdateSandboxPreviewResponses = {
    /**
     * successful operation
     */
    200: Preview;
};

export type UpdateSandboxPreviewResponse = UpdateSandboxPreviewResponses[keyof UpdateSandboxPreviewResponses];

export type GetSandboxPreviewTokensData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type GetSandboxPreviewTokensResponses = {
    /**
     * successful operation
     */
    200: Array<{
        /**
         * When the token was created
         */
        created_at?: string;
        /**
         * The name of the token
         */
        name?: string;
    }>;
};

export type GetSandboxPreviewTokensResponse = GetSandboxPreviewTokensResponses[keyof GetSandboxPreviewTokensResponses];

export type CreateSandboxPreviewTokenData = {
    body: PreviewToken;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens';
};

export type CreateSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * The generated token for the preview
         */
        token?: string;
    };
};

export type CreateSandboxPreviewTokenResponse = CreateSandboxPreviewTokenResponses[keyof CreateSandboxPreviewTokenResponses];

export type DeleteSandboxPreviewTokenData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
        /**
         * Name of the Preview
         */
        previewName: string;
        /**
         * Name of the Token
         */
        tokenName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/previews/{previewName}/tokens/{tokenName}';
};

export type DeleteSandboxPreviewTokenResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Success message
         */
        message?: string;
    };
};

export type DeleteSandboxPreviewTokenResponse = DeleteSandboxPreviewTokenResponses[keyof DeleteSandboxPreviewTokenResponses];

export type StartSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/start';
};

export type StartSandboxErrors = {
    /**
     * Sandbox is already running
     */
    409: unknown;
};

export type StartSandboxResponses = {
    /**
     * successful operation
     */
    200: StartSandbox;
};

export type StartSandboxResponse = StartSandboxResponses[keyof StartSandboxResponses];

export type StopSandboxData = {
    body?: never;
    path: {
        /**
         * Name of the Sandbox
         */
        sandboxName: string;
    };
    query?: never;
    url: '/sandboxes/{sandboxName}/stop';
};

export type StopSandboxErrors = {
    /**
     * Sandbox is not running
     */
    409: unknown;
};

export type StopSandboxResponses = {
    /**
     * successful operation
     */
    200: StopSandbox;
};

export type StopSandboxResponse = StopSandboxResponses[keyof StopSandboxResponses];

export type GetWorkspaceServiceAccountsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type GetWorkspaceServiceAccountsResponses = {
    /**
     * successful operation
     */
    200: Array<{
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    }>;
};

export type GetWorkspaceServiceAccountsResponse = GetWorkspaceServiceAccountsResponses[keyof GetWorkspaceServiceAccountsResponses];

export type CreateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name: string;
    };
    path?: never;
    query?: never;
    url: '/service_accounts';
};

export type CreateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Service account client secret (only returned on creation)
         */
        client_secret?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type CreateWorkspaceServiceAccountResponse = CreateWorkspaceServiceAccountResponses[keyof CreateWorkspaceServiceAccountResponses];

export type DeleteWorkspaceServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type DeleteWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type DeleteWorkspaceServiceAccountResponse = DeleteWorkspaceServiceAccountResponses[keyof DeleteWorkspaceServiceAccountResponses];

export type UpdateWorkspaceServiceAccountData = {
    body: {
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}';
};

export type UpdateWorkspaceServiceAccountResponses = {
    /**
     * successful operation
     */
    200: {
        /**
         * Service account client ID
         */
        client_id?: string;
        /**
         * Creation timestamp
         */
        created_at?: string;
        /**
         * Service account description
         */
        description?: string;
        /**
         * Service account name
         */
        name?: string;
        /**
         * Last update timestamp
         */
        updated_at?: string;
    };
};

export type UpdateWorkspaceServiceAccountResponse = UpdateWorkspaceServiceAccountResponses[keyof UpdateWorkspaceServiceAccountResponses];

export type ListApiKeysForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type ListApiKeysForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: Array<ApiKey>;
};

export type ListApiKeysForServiceAccountResponse = ListApiKeysForServiceAccountResponses[keyof ListApiKeysForServiceAccountResponses];

export type CreateApiKeyForServiceAccountData = {
    body: {
        /**
         * Expiration period for the API key
         */
        expires_in?: string;
        /**
         * Name for the API key
         */
        name?: string;
    };
    path: {
        /**
         * Client ID
         */
        clientId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys';
};

export type CreateApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: ApiKey;
};

export type CreateApiKeyForServiceAccountResponse = CreateApiKeyForServiceAccountResponses[keyof CreateApiKeyForServiceAccountResponses];

export type DeleteApiKeyForServiceAccountData = {
    body?: never;
    path: {
        /**
         * Client ID
         */
        clientId: string;
        /**
         * Api key id
         */
        apiKeyId: string;
    };
    query?: never;
    url: '/service_accounts/{clientId}/api_keys/{apiKeyId}';
};

export type DeleteApiKeyForServiceAccountResponses = {
    /**
     * successful operation
     */
    200: unknown;
};

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/templates';
};

export type ListTemplatesResponses = {
    /**
     * successful operation
     */
    200: Array<Template>;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Name of the template
         */
        templateName: string;
    };
    query?: never;
    url: '/templates/{templateName}';
};

export type GetTemplateResponses = {
    /**
     * successful operation
     */
    200: Template;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type GetTemplateContentsData = {
    body?: never;
    path: {
        templateName: string;
    };
    query?: never;
    url: '/templates/{templateName}/contents';
};

export type GetTemplateContentsResponses = {
    /**
     * List of files in the template
     */
    200: Array<string>;
};

export type GetTemplateContentsResponse = GetTemplateContentsResponses[keyof GetTemplateContentsResponses];

export type GetTemplateFileContentsData = {
    body?: never;
    path: {
        templateName: string;
        fileName: string;
    };
    query?: never;
    url: '/templates/{templateName}/contents/{fileName}';
};

export type GetTemplateFileContentsResponses = {
    /**
     * Content of the file
     */
    200: string;
};

export type GetTemplateFileContentsResponse = GetTemplateFileContentsResponses[keyof GetTemplateFileContentsResponses];

export type ListWorkspaceUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/users';
};

export type ListWorkspaceUsersResponses = {
    /**
     * successful operation
     */
    200: Array<WorkspaceUser>;
};

export type ListWorkspaceUsersResponse = ListWorkspaceUsersResponses[keyof ListWorkspaceUsersResponses];

export type InviteWorkspaceUserData = {
    /**
     * Email of the user to invite
     */
    body: {
        email?: string;
    };
    path?: never;
    query?: never;
    url: '/users';
};

export type InviteWorkspaceUserErrors = {
    /**
     * invalid email format
     */
    400: unknown;
    /**
     * workspace not found
     */
    404: unknown;
};

export type InviteWorkspaceUserResponses = {
    /**
     * successful operation
     */
    200: PendingInvitation;
};

export type InviteWorkspaceUserResponse = InviteWorkspaceUserResponses[keyof InviteWorkspaceUserResponses];

export type RemoveWorkspaceUserData = {
    body?: never;
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type RemoveWorkspaceUserErrors = {
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type RemoveWorkspaceUserResponses = {
    /**
     * User successfully removed or invitation revoked
     */
    200: unknown;
};

export type UpdateWorkspaceUserRoleData = {
    body: {
        /**
         * The new role to assign to the user
         */
        role: string;
    };
    path: {
        /**
         * Sub or email of the user
         */
        subOrEmail: string;
    };
    query?: never;
    url: '/users/{subOrEmail}';
};

export type UpdateWorkspaceUserRoleErrors = {
    /**
     * Invalid role provided
     */
    400: unknown;
    /**
     * Workspace or user not found
     */
    404: unknown;
};

export type UpdateWorkspaceUserRoleResponses = {
    /**
     * User role updated successfully
     */
    200: WorkspaceUser;
};

export type UpdateWorkspaceUserRoleResponse = UpdateWorkspaceUserRoleResponses[keyof UpdateWorkspaceUserRoleResponses];

export type ListWorkspacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type ListWorkspacesResponses = {
    /**
     * successful operation
     */
    200: Array<Workspace>;
};

export type ListWorkspacesResponse = ListWorkspacesResponses[keyof ListWorkspacesResponses];

export type CreateWorspaceData = {
    body: Workspace;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type CreateWorspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type CreateWorspaceResponse = CreateWorspaceResponses[keyof CreateWorspaceResponses];

export type DeleteWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type DeleteWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type DeleteWorkspaceResponse = DeleteWorkspaceResponses[keyof DeleteWorkspaceResponses];

export type GetWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type GetWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type GetWorkspaceResponse = GetWorkspaceResponses[keyof GetWorkspaceResponses];

export type UpdateWorkspaceData = {
    body: Workspace;
    path: {
        /**
         * name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}';
};

export type UpdateWorkspaceResponses = {
    /**
     * successful operation
     */
    200: Workspace;
};

export type UpdateWorkspaceResponse = UpdateWorkspaceResponses[keyof UpdateWorkspaceResponses];

export type DeclineWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/decline';
};

export type DeclineWorkspaceInvitationResponses = {
    /**
     * Invitation successfully declined
     */
    200: PendingInvitation;
};

export type DeclineWorkspaceInvitationResponse = DeclineWorkspaceInvitationResponses[keyof DeclineWorkspaceInvitationResponses];

export type AcceptWorkspaceInvitationData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/join';
};

export type AcceptWorkspaceInvitationErrors = {
    /**
     * Workspace or invitation not found
     */
    404: unknown;
};

export type AcceptWorkspaceInvitationResponses = {
    /**
     * Invitation successfully accepted
     */
    200: PendingInvitationAccept;
};

export type AcceptWorkspaceInvitationResponse = AcceptWorkspaceInvitationResponses[keyof AcceptWorkspaceInvitationResponses];

export type LeaveWorkspaceData = {
    body?: never;
    path: {
        /**
         * Name of the workspace
         */
        workspaceName: string;
    };
    query?: never;
    url: '/workspaces/{workspaceName}/leave';
};

export type LeaveWorkspaceErrors = {
    /**
     * Workspace not found
     */
    404: unknown;
};

export type LeaveWorkspaceResponses = {
    /**
     * Workspace successfully left
     */
    200: Workspace;
};

export type LeaveWorkspaceResponse = LeaveWorkspaceResponses[keyof LeaveWorkspaceResponses];

export type CheckWorkspaceAvailabilityData = {
    body: {
        name: string;
    };
    path?: never;
    query?: never;
    url: '/workspaces/availability';
};

export type CheckWorkspaceAvailabilityResponses = {
    /**
     * successful operation
     */
    200: boolean;
};

export type CheckWorkspaceAvailabilityResponse = CheckWorkspaceAvailabilityResponses[keyof CheckWorkspaceAvailabilityResponses];

export type ClientOptions = {
    baseUrl: 'https://api.blaxel.ai/v0' | 'https://run.blaxel.ai' | (string & {});
};