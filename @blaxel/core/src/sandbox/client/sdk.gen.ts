// This file is auto-generated by @hey-api/openapi-ts

import { type Options as ClientOptions, type TDataShape, type Client, formDataBodySerializer } from '@hey-api/client-fetch';
import type { PutCodegenFastapplyByPathData, PutCodegenFastapplyByPathResponse, PutCodegenFastapplyByPathError, GetCodegenRerankingByPathData, GetCodegenRerankingByPathResponse, GetCodegenRerankingByPathError, GetFilesystemContentSearchByPathData, GetFilesystemContentSearchByPathResponse, GetFilesystemContentSearchByPathError, GetFilesystemFindByPathData, GetFilesystemFindByPathResponse, GetFilesystemFindByPathError, GetFilesystemMultipartData, GetFilesystemMultipartResponse, GetFilesystemMultipartError, DeleteFilesystemMultipartByUploadIdAbortData, DeleteFilesystemMultipartByUploadIdAbortResponse, DeleteFilesystemMultipartByUploadIdAbortError, PostFilesystemMultipartByUploadIdCompleteData, PostFilesystemMultipartByUploadIdCompleteResponse, PostFilesystemMultipartByUploadIdCompleteError, PutFilesystemMultipartByUploadIdPartData, PutFilesystemMultipartByUploadIdPartResponse, PutFilesystemMultipartByUploadIdPartError, GetFilesystemMultipartByUploadIdPartsData, GetFilesystemMultipartByUploadIdPartsResponse, GetFilesystemMultipartByUploadIdPartsError, PostFilesystemMultipartInitiateByPathData, PostFilesystemMultipartInitiateByPathResponse, PostFilesystemMultipartInitiateByPathError, GetFilesystemSearchByPathData, GetFilesystemSearchByPathResponse, GetFilesystemSearchByPathError, DeleteFilesystemByPathData, DeleteFilesystemByPathResponse, DeleteFilesystemByPathError, GetFilesystemByPathData, GetFilesystemByPathResponse, GetFilesystemByPathError, PutFilesystemByPathData, PutFilesystemByPathResponse, PutFilesystemByPathError, DeleteFilesystemTreeByPathData, DeleteFilesystemTreeByPathResponse, DeleteFilesystemTreeByPathError, GetFilesystemTreeByPathData, GetFilesystemTreeByPathResponse, GetFilesystemTreeByPathError, PutFilesystemTreeByPathData, PutFilesystemTreeByPathResponse, PutFilesystemTreeByPathError, GetHealthData, GetHealthResponse, DeleteNetworkProcessByPidMonitorData, DeleteNetworkProcessByPidMonitorResponse, DeleteNetworkProcessByPidMonitorError, PostNetworkProcessByPidMonitorData, PostNetworkProcessByPidMonitorResponse, PostNetworkProcessByPidMonitorError, GetNetworkProcessByPidPortsData, GetNetworkProcessByPidPortsResponse, GetNetworkProcessByPidPortsError, GetProcessData, GetProcessResponse, PostProcessData, PostProcessResponse, PostProcessError, DeleteProcessByIdentifierData, DeleteProcessByIdentifierResponse, DeleteProcessByIdentifierError, GetProcessByIdentifierData, GetProcessByIdentifierResponse, GetProcessByIdentifierError, DeleteProcessByIdentifierKillData, DeleteProcessByIdentifierKillResponse, DeleteProcessByIdentifierKillError, GetProcessByIdentifierLogsData, GetProcessByIdentifierLogsResponse, GetProcessByIdentifierLogsError, GetProcessByIdentifierLogsStreamData, GetProcessByIdentifierLogsStreamResponse, GetProcessByIdentifierLogsStreamError, PostUpgradeData, PostUpgradeResponse, PostUpgradeError, GetWatchFilesystemByPathData, GetWatchFilesystemByPathResponse, GetWatchFilesystemByPathError } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Apply code edit
 * Uses the configured LLM provider (Relace or Morph) to apply a code edit to the original content.
 *
 * To use this endpoint as an agent tool, follow these guidelines:
 *
 * Use this tool to make an edit to an existing file. This will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.
 *
 * When writing the edit, you should specify each edit in sequence, with the special comment "// ... existing code ..." to represent unchanged code in between edited lines.
 *
 * Example format:
 * // ... existing code ...
 * FIRST_EDIT
 * // ... existing code ...
 * SECOND_EDIT
 * // ... existing code ...
 * THIRD_EDIT
 * // ... existing code ...
 *
 * You should still bias towards repeating as few lines of the original file as possible to convey the change. But, each edit should contain minimally sufficient context of unchanged lines around the code you're editing to resolve ambiguity.
 *
 * DO NOT omit spans of pre-existing code (or comments) without using the "// ... existing code ..." comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.
 *
 * If you plan on deleting a section, you must provide context before and after to delete it. If the initial code is "Block 1\nBlock 2\nBlock 3", and you want to remove Block 2, you would output "// ... existing code ...\nBlock 1\nBlock 3\n// ... existing code ...".
 *
 * Make sure it is clear what the edit should be, and where it should be applied. Make edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.
 */
export const putCodegenFastapplyByPath = <ThrowOnError extends boolean = false>(options: Options<PutCodegenFastapplyByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutCodegenFastapplyByPathResponse, PutCodegenFastapplyByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codegen/fastapply/{path}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Code reranking/semantic search
 * Uses Relace's code reranking model to find the most relevant files for a given query. This is useful as a first pass in agentic exploration to narrow down the search space.
 *
 * Based on: https://docs.relace.ai/docs/code-reranker/agent
 *
 * Query Construction: The query can be a short question or a more detailed conversation with the user request included. For a first pass, use the full conversation; for subsequent calls, use more targeted questions.
 *
 * Token Limit and Score Threshold: For 200k token context models like Claude 4 Sonnet, recommended defaults are scoreThreshold=0.5 and tokenLimit=30000.
 *
 * The response will be a list of file paths and contents ordered from most relevant to least relevant.
 */
export const getCodegenRerankingByPath = <ThrowOnError extends boolean = false>(options: Options<GetCodegenRerankingByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCodegenRerankingByPathResponse, GetCodegenRerankingByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/codegen/reranking/{path}',
        ...options
    });
};

/**
 * Search for text content in files
 * Searches for text content inside files using ripgrep. Returns matching lines with context.
 */
export const getFilesystemContentSearchByPath = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemContentSearchByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemContentSearchByPathResponse, GetFilesystemContentSearchByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-content-search/{path}',
        ...options
    });
};

/**
 * Find files and directories
 * Finds files and directories using the find command.
 */
export const getFilesystemFindByPath = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemFindByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemFindByPathResponse, GetFilesystemFindByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-find/{path}',
        ...options
    });
};

/**
 * List multipart uploads
 * List all active multipart uploads
 */
export const getFilesystemMultipart = <ThrowOnError extends boolean = false>(options?: Options<GetFilesystemMultipartData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetFilesystemMultipartResponse, GetFilesystemMultipartError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart',
        ...options
    });
};

/**
 * Abort multipart upload
 * Abort a multipart upload and clean up all parts
 */
export const deleteFilesystemMultipartByUploadIdAbort = <ThrowOnError extends boolean = false>(options: Options<DeleteFilesystemMultipartByUploadIdAbortData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFilesystemMultipartByUploadIdAbortResponse, DeleteFilesystemMultipartByUploadIdAbortError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart/{uploadId}/abort',
        ...options
    });
};

/**
 * Complete multipart upload
 * Complete a multipart upload by assembling all parts
 */
export const postFilesystemMultipartByUploadIdComplete = <ThrowOnError extends boolean = false>(options: Options<PostFilesystemMultipartByUploadIdCompleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostFilesystemMultipartByUploadIdCompleteResponse, PostFilesystemMultipartByUploadIdCompleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart/{uploadId}/complete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Upload part
 * Upload a single part of a multipart upload
 */
export const putFilesystemMultipartByUploadIdPart = <ThrowOnError extends boolean = false>(options: Options<PutFilesystemMultipartByUploadIdPartData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutFilesystemMultipartByUploadIdPartResponse, PutFilesystemMultipartByUploadIdPartError, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart/{uploadId}/part',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * List parts
 * List all uploaded parts for a multipart upload
 */
export const getFilesystemMultipartByUploadIdParts = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemMultipartByUploadIdPartsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemMultipartByUploadIdPartsResponse, GetFilesystemMultipartByUploadIdPartsError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart/{uploadId}/parts',
        ...options
    });
};

/**
 * Initiate multipart upload
 * Initiate a multipart upload session for a file
 */
export const postFilesystemMultipartInitiateByPath = <ThrowOnError extends boolean = false>(options: Options<PostFilesystemMultipartInitiateByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostFilesystemMultipartInitiateByPathResponse, PostFilesystemMultipartInitiateByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-multipart/initiate/{path}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Fuzzy search for files and directories
 * Performs fuzzy search on filesystem paths using fuzzy matching algorithm. Optimized alternative to find and grep commands.
 */
export const getFilesystemSearchByPath = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemSearchByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemSearchByPathResponse, GetFilesystemSearchByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem-search/{path}',
        ...options
    });
};

/**
 * Delete file or directory
 * Delete a file or directory
 */
export const deleteFilesystemByPath = <ThrowOnError extends boolean = false>(options: Options<DeleteFilesystemByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFilesystemByPathResponse, DeleteFilesystemByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/{path}',
        ...options
    });
};

/**
 * Get file or directory information
 * Get content of a file or listing of a directory. Use Accept header to control response format for files.
 */
export const getFilesystemByPath = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemByPathResponse, GetFilesystemByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/{path}',
        ...options
    });
};

/**
 * Create or update a file or directory
 * Create or update a file or directory
 */
export const putFilesystemByPath = <ThrowOnError extends boolean = false>(options: Options<PutFilesystemByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutFilesystemByPathResponse, PutFilesystemByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/{path}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete directory tree
 * Delete a directory tree recursively
 */
export const deleteFilesystemTreeByPath = <ThrowOnError extends boolean = false>(options: Options<DeleteFilesystemTreeByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFilesystemTreeByPathResponse, DeleteFilesystemTreeByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/tree/{path}',
        ...options
    });
};

/**
 * Get directory tree
 * Get a recursive directory tree structure starting from the specified path
 */
export const getFilesystemTreeByPath = <ThrowOnError extends boolean = false>(options: Options<GetFilesystemTreeByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFilesystemTreeByPathResponse, GetFilesystemTreeByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/tree/{path}',
        ...options
    });
};

/**
 * Create or update directory tree
 * Create or update multiple files within a directory tree structure
 */
export const putFilesystemTreeByPath = <ThrowOnError extends boolean = false>(options: Options<PutFilesystemTreeByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutFilesystemTreeByPathResponse, PutFilesystemTreeByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/filesystem/tree/{path}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Health check
 * Returns health status and system information including upgrade count and binary details
 * Also includes last upgrade attempt status with detailed error information if available
 */
export const getHealth = <ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetHealthResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/health',
        ...options
    });
};

/**
 * Stop monitoring ports for a process
 * Stop monitoring for new ports opened by a process
 */
export const deleteNetworkProcessByPidMonitor = <ThrowOnError extends boolean = false>(options: Options<DeleteNetworkProcessByPidMonitorData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteNetworkProcessByPidMonitorResponse, DeleteNetworkProcessByPidMonitorError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/network/process/{pid}/monitor',
        ...options
    });
};

/**
 * Start monitoring ports for a process
 * Start monitoring for new ports opened by a process
 */
export const postNetworkProcessByPidMonitor = <ThrowOnError extends boolean = false>(options: Options<PostNetworkProcessByPidMonitorData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostNetworkProcessByPidMonitorResponse, PostNetworkProcessByPidMonitorError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/network/process/{pid}/monitor',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get open ports for a process
 * Get a list of all open ports for a process
 */
export const getNetworkProcessByPidPorts = <ThrowOnError extends boolean = false>(options: Options<GetNetworkProcessByPidPortsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetNetworkProcessByPidPortsResponse, GetNetworkProcessByPidPortsError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/network/process/{pid}/ports',
        ...options
    });
};

/**
 * List all processes
 * Get a list of all running and completed processes
 */
export const getProcess = <ThrowOnError extends boolean = false>(options?: Options<GetProcessData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetProcessResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process',
        ...options
    });
};

/**
 * Execute a command
 * Execute a command and return process information. If Accept header is text/event-stream, streams logs in SSE format and returns the process response as a final event.
 */
export const postProcess = <ThrowOnError extends boolean = false>(options: Options<PostProcessData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostProcessResponse, PostProcessError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Stop a process
 * Gracefully stop a running process
 */
export const deleteProcessByIdentifier = <ThrowOnError extends boolean = false>(options: Options<DeleteProcessByIdentifierData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteProcessByIdentifierResponse, DeleteProcessByIdentifierError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process/{identifier}',
        ...options
    });
};

/**
 * Get process by identifier
 * Get information about a process by its PID or name
 */
export const getProcessByIdentifier = <ThrowOnError extends boolean = false>(options: Options<GetProcessByIdentifierData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProcessByIdentifierResponse, GetProcessByIdentifierError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process/{identifier}',
        ...options
    });
};

/**
 * Kill a process
 * Forcefully kill a running process
 */
export const deleteProcessByIdentifierKill = <ThrowOnError extends boolean = false>(options: Options<DeleteProcessByIdentifierKillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteProcessByIdentifierKillResponse, DeleteProcessByIdentifierKillError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process/{identifier}/kill',
        ...options
    });
};

/**
 * Get process logs
 * Get the stdout and stderr output of a process
 */
export const getProcessByIdentifierLogs = <ThrowOnError extends boolean = false>(options: Options<GetProcessByIdentifierLogsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProcessByIdentifierLogsResponse, GetProcessByIdentifierLogsError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process/{identifier}/logs',
        ...options
    });
};

/**
 * Stream process logs in real time
 * Streams the stdout and stderr output of a process in real time, one line per log, prefixed with 'stdout:' or 'stderr:'. Closes when the process exits or the client disconnects.
 */
export const getProcessByIdentifierLogsStream = <ThrowOnError extends boolean = false>(options: Options<GetProcessByIdentifierLogsStreamData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetProcessByIdentifierLogsStreamResponse, GetProcessByIdentifierLogsStreamError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/process/{identifier}/logs/stream',
        ...options
    });
};

/**
 * Upgrade the sandbox-api
 * Triggers an upgrade of the sandbox-api process. Returns 200 immediately before upgrading.
 * The upgrade will: download the specified binary from GitHub releases, validate it, and restart.
 * All running processes will be preserved across the upgrade.
 * Available versions: "develop" (default), "main", "latest", or specific tag like "v1.0.0"
 * You can also specify a custom baseUrl for forks (defaults to https://github.com/blaxel-ai/sandbox/releases)
 */
export const postUpgrade = <ThrowOnError extends boolean = false>(options?: Options<PostUpgradeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostUpgradeResponse, PostUpgradeError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Stream file modification events in a directory
 * Streams the path of modified files (one per line) in the given directory. Closes when the client disconnects.
 */
export const getWatchFilesystemByPath = <ThrowOnError extends boolean = false>(options: Options<GetWatchFilesystemByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetWatchFilesystemByPathResponse, GetWatchFilesystemByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/watch/filesystem/{path}',
        ...options
    });
};